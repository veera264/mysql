  <HTML>
  <HEAD>
  
  <TITLE>MySQL Reference Manual for version 5.0.0-alpha. - 13  Functions and Operators</TITLE>
    <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
  </HEAD>
  <BODY>

<H1><A NAME="Functions" HREF="index.html#Functions">13  Functions and Operators</A></H1>

<P>
<A NAME="IDX1171"></A>
<A NAME="IDX1172"></A>
<A NAME="IDX1173"></A>

</P>

<P>
Expressions can be used at several points in SQL statements, such as in the
<code>ORDER BY</code> or <code>HAVING</code> clauses of <code>SELECT</code> statements, in the
<code>WHERE</code> clause of a <code>SELECT</code>, <code>DELETE</code>, or <code>UPDATE</code>
statement, or in <code>SET</code> statements.  Expressions can be written using
literal values, column values, <code>NULL</code>, functions, and operators.
This chapter describes the functions and operators that are allowed for
writing expressions in MySQL.

</P>
<P>
An expression that contains <code>NULL</code> always produces a <code>NULL</code> value
unless otherwise indicated in the documentation for a particular function or
operator.

</P>
<P>
<strong>Note:</strong> By default, there must be no whitespace between a function
name and the parenthesis following it. This helps the MySQL parser
distinguish between function calls and references to tables or columns that
happen to have the same name as a function.  Spaces around function
arguments are permitted, though.

</P>
<P>
You can tell the MySQL server to accept spaces after function names by
starting it with the <code>--sql-mode=IGNORE_SPACE</code> option. Individual client
programs can request this behavior by using the
<code>CLIENT_IGNORE_SPACE</code> option for <code>mysql_real_connect()</code>.
In either case, all function names will become reserved words.
See section 5.2.2  The Server SQL Mode.

</P>
<P>
For the sake of brevity, most examples in this chapter display the output
from the <code>mysql</code> program in abbreviated form.  Instead of showing
examples in this format:

</P>

<PRE>
mysql&#62; SELECT MOD(29,9);
+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
1 rows in set (0.00 sec)
</PRE>

<P>
This format is used instead:

</P>

<PRE>
mysql&#62; SELECT MOD(29,9);
        -&#62; 2
</PRE>



<H2><A NAME="Non-typed_Operators" HREF="index.html#Non-typed_Operators">13.1  Operators</A></H2>



<H3><A NAME="Parentheses" HREF="index.html#Parentheses">13.1.1  Parentheses</A></H3>

<P>
<A NAME="IDX1174"></A>
<A NAME="IDX1175"></A>

</P>
<P>
<A NAME="IDX1176"></A>
<A NAME="IDX1177"></A>

</P>
<DL COMPACT>

<DT><code><b>( ... )</b></code><DD>
Use parentheses to force the order of evaluation in an expression.  For
example:


<PRE>
mysql&#62; SELECT 1+2*3;
        -&#62; 7
mysql&#62; SELECT (1+2)*3;
        -&#62; 9
</PRE>

</DL>



<H3><A NAME="Comparison_Operators" HREF="index.html#Comparison_Operators">13.1.2  Comparison Operators</A></H3>

<P>
<A NAME="IDX1178"></A>

</P>
<P>
<A NAME="IDX1179"></A>
<A NAME="IDX1180"></A>

</P>
<P>
Comparison operations result in a value of <code>1</code> (TRUE), <code>0</code> (FALSE),
or <code>NULL</code>. These operations work for both numbers and strings.  Strings
are automatically converted to numbers and numbers to strings as necessary.

</P>
<P>
MySQL performs comparisons using the following
rules:

</P>

<UL>
<LI>

If one or both arguments are <code>NULL</code>, the result of the comparison is
<code>NULL</code>, except for the <code>NULL</code>-safe <code>&#60;=&#62;</code> equality comparison
operator.

<LI>

If both arguments in a comparison operation are strings, they are compared as
strings.

<LI>

If both arguments are integers, they are compared as integers.

<LI>

Hexadecimal values are treated as binary strings if not compared to a number.

<LI>

<A NAME="IDX1181"></A>
<A NAME="IDX1182"></A>
If one of the arguments is a <code>TIMESTAMP</code> or <code>DATETIME</code> column and
the other argument is a constant, the constant is converted
to a timestamp before the comparison is performed. This is done to be more
ODBC-friendly.

<LI>

In all other cases, the arguments are compared as floating-point (real)
numbers.
</UL>

<P>
By default, string comparisons are not case sensitive and use the
current character set (ISO-8859-1 Latin1 by default, which also works
excellently for English).

</P>
<P>
The following examples illustrate conversion of strings to numbers for comparison
operations:

</P>

<PRE>
mysql&#62; SELECT 1 &#62; '6x';
        -&#62; 0
mysql&#62; SELECT 7 &#62; '6x';
        -&#62; 1
mysql&#62; SELECT 0 &#62; 'x6';
        -&#62; 0
mysql&#62; SELECT 0 = 'x6';
        -&#62; 1
</PRE>

<P>
Note that when you are comparing a string column with a number, MySQL can't
use an index on the column to quickly look up the value.  If <code>str_col</code>
is an indexed string column, the index cannot be used when performing the
lookup in the following statement:

</P>

<PRE>
SELECT * FROM tbl_name WHERE str_col=1;
</PRE>

<P>
The reason for this is that there are many different strings that may
convert to the value <code>1</code>:  <code>'1'</code>, <code>' 1'</code>, <code>'1a'</code> ...

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1183"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>=</code></b></td>
 </tr>
</table>
<br>
<code><b>=</b></code><DD></A>
 <A NAME="IDX1184"></A>
 
Equal:


<PRE>
mysql&#62; SELECT 1 = 0;
        -&#62; 0
mysql&#62; SELECT '0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.01' = 0;
        -&#62; 0
mysql&#62; SELECT '.01' = 0.01;
        -&#62; 1
</PRE>

<A NAME="IDX1185"></A>
<br><br><br><A NAME="IDX1186"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#60;=&#62;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#60;=&#62;</b></code><DD></A>
<code>NULL</code>-safe equal.
This operator performs an equality comparison like the <code>=</code> operator, but
returns <code>1</code> rather than <code>NULL</code> if both operands are <code>NULL</code>,
and <code>0</code> rather than <code>NULL</code> if one operand is <code>NULL</code>.


<PRE>
mysql&#62; SELECT 1 &#60;=&#62; 1, NULL &#60;=&#62; NULL, 1 &#60;=&#62; NULL;
        -&#62; 1, 1, 0
mysql&#62; SELECT 1 = 1, NULL = NULL, 1 = NULL;
        -&#62; 1, NULL, NULL
</PRE>

<A NAME="IDX1187"></A>
<A NAME="IDX1188"></A>
<A NAME="IDX1189"></A>
<br><br><br><A NAME="IDX1190"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#60;&#62;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#60;&#62;</b></code><DD></A>
<DT><code><b>!=</b></code><DD>
Not equal:


<PRE>
mysql&#62; SELECT '.01' &#60;&#62; '0.01';
        -&#62; 1
mysql&#62; SELECT .01 &#60;&#62; '0.01';
        -&#62; 0
mysql&#62; SELECT 'zapp' &#60;&#62; 'zappp';
        -&#62; 1
</PRE>

<A NAME="IDX1191"></A>
<br><br><br><A NAME="IDX1192"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#60;=</code></b></td>
 </tr>
</table>
<br>
<code><b>&#60;=</b></code><DD></A>
Less than or equal:


<PRE>
mysql&#62; SELECT 0.1 &#60;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1193"></A>
<br><br><br><A NAME="IDX1194"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#60;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#60;</b></code><DD></A>
Less than:


<PRE>
mysql&#62; SELECT 2 &#60; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1195"></A>
<br><br><br><A NAME="IDX1196"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#62;=</code></b></td>
 </tr>
</table>
<br>
<code><b>&#62;=</b></code><DD></A>
Greater than or equal:


<PRE>
mysql&#62; SELECT 2 &#62;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1197"></A>
<br><br><br><A NAME="IDX1198"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#62;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#62;</b></code><DD></A>
Greater than:


<PRE>
mysql&#62; SELECT 2 &#62; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1199"></A>
<A NAME="IDX1200"></A>
<br><br><br><A NAME="IDX1201"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>IS NULL</code></b></td>
 </tr>
</table>
<br>
<code><b>IS NULL</b></code><DD></A>
<DT><code><b>IS NOT NULL</b></code><DD>
Test whether a value is or is not <code>NULL</code>.


<PRE>
mysql&#62; SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL;
        -&#62; 0, 0, 1
mysql&#62; SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
        -&#62; 1, 1, 0
</PRE>

<A NAME="IDX1202"></A>
<A NAME="IDX1203"></A>
To be able to work well with ODBC programs, MySQL supports the following
extra features when using <code>IS NULL</code>:


<UL>
<LI>

You can find the row that contains the most recent <code>AUTO_INCREMENT</code> value
by issuing a statement of the following form immediately after generating the
value:


<PRE>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</PRE>

This behavior can be disabled by setting <code>SQL_AUTO_IS_NULL=0</code>.
See section <A HREF="manual_SQL_Syntax.html#SET_OPTION">14.5.3.1  <code>SET</code> Syntax</A>.

<LI>

For <code>DATE</code> and <code>DATETIME</code> columns that are declared as <code>NOT
NULL</code>, you can find the special date <code>'0000-00-00'</code> by using a statement
like this:


<PRE>
SELECT * FROM tbl_name WHERE date_column IS NULL
</PRE>

This is needed to get some ODBC applications to work, because ODBC doesn't
support a <code>'0000-00-00'</code> date.

</UL>

<br><br><br><A NAME="IDX1204"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr BETWEEN min AND max</code></b></td>
 </tr>
</table>
<br>
<code><b>expr BETWEEN min AND max</b></code><DD></A>
If <code>expr</code> is greater than or equal to <code>min</code> and <code>expr</code> is
less than or equal to <code>max</code>, <code>BETWEEN</code> returns <code>1</code>,
otherwise it returns <code>0</code>.  This is equivalent to the expression
<code>(min &#60;= expr AND expr &#60;= max)</code> if all the arguments are of the
same type. Otherwise type conversion takes place, according to the rules
described at the beginning of this section, but applied to all the three
arguments. <strong>Note:</strong> Before MySQL
4.0.5, arguments were converted to the type of <code>expr</code> instead.


<PRE>
mysql&#62; SELECT 1 BETWEEN 2 AND 3;
        -&#62; 0
mysql&#62; SELECT 'b' BETWEEN 'a' AND 'c';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND '3';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND 'x-3';
        -&#62; 0
</PRE>

<br><br><br><A NAME="IDX1205"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr NOT BETWEEN min AND max</code></b></td>
 </tr>
</table>
<br>
<code><b>expr NOT BETWEEN min AND max</b></code><DD></A>
This is the same as <code>NOT (expr BETWEEN min AND max)</code>.

<br><br><br><A NAME="IDX1206"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>GREATEST(X,Y,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>GREATEST(X,Y,...)</b></code><DD></A>
Returns the largest (maximum-valued) argument.
The arguments are compared using the same rules as for <code>LEAST()</code>.


<PRE>
mysql&#62; SELECT GREATEST(2,0);
        -&#62; 2
mysql&#62; SELECT GREATEST(34.0,3.0,5.0,767.0);
        -&#62; 767.0
mysql&#62; SELECT GREATEST('B','A','C');
        -&#62; 'C'
</PRE>

Before MySQL 3.22.5, you can use <code>MAX()</code>
instead of <code>GREATEST()</code>.

<br><br><br><A NAME="IDX1207"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr IN (value,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>expr IN (value,...)</b></code><DD></A>
Returns <code>1</code> if <code>expr</code> is any of the values in the <code>IN</code> list,
else returns <code>0</code>.  If all values are constants, they are
evaluated according to the type of <code>expr</code> and sorted. The search for the
item then is done using a binary search. This means <code>IN</code> is very quick
if the <code>IN</code> value list consists entirely of constants.  If <code>expr</code>
is a case-sensitive string expression, the string comparison is performed in
case-sensitive fashion.


<PRE>
mysql&#62; SELECT 2 IN (0,3,5,'wefwf');
        -&#62; 0
mysql&#62; SELECT 'wefwf' IN (0,3,5,'wefwf');
        -&#62; 1
</PRE>

The number of values in the <code>IN</code> list is only limited by the
<code>max_allowed_packet</code> value.

To comply with the SQL-99 standard,
from MySQL 4.1 on
<code>IN</code> returns <code>NULL</code> 
not only if the expression on the left hand side is <code>NULL</code>, but also if
no match is found in the list and one of the expressions in the list is 
<code>NULL</code>.

From MySQL 4.1 on, <code>IN()</code> syntax also is used to write certain types of
subqueries.
See section <A HREF="manual_SQL_Syntax.html#ANY_IN_SOME_subqueries">14.1.8.3  Subqueries with <code>ANY</code>, <code>IN</code>, and <code>SOME</code></A>.

<br><br><br><A NAME="IDX1208"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr NOT IN (value,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>expr NOT IN (value,...)</b></code><DD></A>
This is the same as <code>NOT (expr IN (value,...))</code>.

<br><br><br><A NAME="IDX1209"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ISNULL(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>ISNULL(expr)</b></code><DD></A>
If <code>expr</code> is <code>NULL</code>, <code>ISNULL()</code> returns <code>1</code>, otherwise
it returns <code>0</code>.


<PRE>
mysql&#62; SELECT ISNULL(1+1);
        -&#62; 0
mysql&#62; SELECT ISNULL(1/0);
        -&#62; 1
</PRE>

Note that a comparison of <code>NULL</code> values using <code>=</code> will always be
false!

<A NAME="IDX1210"></A>
<br><br><br><A NAME="IDX1211"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COALESCE(value,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>COALESCE(value,...)</b></code><DD></A>
Returns the first non-<code>NULL</code> value in the list.


<PRE>
mysql&#62; SELECT COALESCE(NULL,1);
        -&#62; 1
mysql&#62; SELECT COALESCE(NULL,NULL,NULL);
        -&#62; NULL
</PRE>

<br><br><br><A NAME="IDX1212"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>INTERVAL(N,N1,N2,N3,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>INTERVAL(N,N1,N2,N3,...)</b></code><DD></A>
Returns <code>0</code> if <code>N</code> &#60; <code>N1</code>, <code>1</code> if <code>N</code> &#60; <code>N2</code>
and so on or <code>-1</code> if <code>N</code> is <code>NULL</code>. All arguments are treated
as integers.  It is required that <code>N1</code> &#60; <code>N2</code> &#60; <code>N3</code> &#60; 
<code>...</code> &#60; <code>Nn</code> for this function to work correctly. This is because
a binary search is used (very fast).


<PRE>
mysql&#62; SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&#62; 3
mysql&#62; SELECT INTERVAL(10, 1, 10, 100, 1000);
        -&#62; 2
mysql&#62; SELECT INTERVAL(22, 23, 30, 44, 200);
        -&#62; 0
</PRE>

<br><br><br><A NAME="IDX1213"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LEAST(X,Y,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>LEAST(X,Y,...)</b></code><DD></A>
With two or more arguments, returns the smallest (minimum-valued) argument.
The arguments are compared using the following rules.


<UL>
<LI>

If the return value is used in an <code>INTEGER</code> context or all arguments
are integer-valued, they are compared as integers.

<LI>

If the return value is used in a <code>REAL</code> context or all arguments are
real-valued, they are compared as reals.

<LI>

If any argument is a case-sensitive string, the arguments are compared
as case-sensitive strings.

<LI>

In other cases, the arguments are compared as case-insensitive strings.
</UL>


<PRE>
mysql&#62; SELECT LEAST(2,0);
        -&#62; 0
mysql&#62; SELECT LEAST(34.0,3.0,5.0,767.0);
        -&#62; 3.0
mysql&#62; SELECT LEAST('B','A','C');
        -&#62; 'A'
</PRE>

Before MySQL 3.22.5, you can use <code>MIN()</code>
instead of <code>LEAST()</code>.

Note that the preceding conversion rules can produce strange results in some
borderline cases:


<PRE>
mysql&#62; SELECT CAST(LEAST(3600, 9223372036854775808.0) as SIGNED);
        -&#62; -9223372036854775808
</PRE>

This happens because MySQL reads <code>9223372036854775808.0</code> in an
integer context. The integer representation is not good enough to
hold the value, so it wraps to a signed integer.

</DL>



<H3><A NAME="Logical_Operators" HREF="index.html#Logical_Operators">13.1.3  Logical Operators</A></H3>

<P>
<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>

</P>
<P>
In SQL, all logical operators evaluate to TRUE, FALSE, or <code>NULL</code> (UNKNOWN).
In MySQL, these are implemented as <code>1</code> (TRUE), <code>0</code> (FALSE),
and <code>NULL</code>. Most of this is common to different SQL database servers,
although some servers may return any non-zero value for TRUE.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1216"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>NOT</code></b></td>
 </tr>
</table>
<br>
<code><b>NOT</b></code><DD></A>
 <br><br><br><A NAME="IDX1217"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>!</code></b></td>
 </tr>
</table>
<br>
<code><b>!</b></code><DD></A>
Logical NOT.
Evaluates to <code>1</code> if the operand is <code>0</code>,
to <code>0</code> if the operand is non-zero,
and <code>NOT NULL</code> returns <code>NULL</code>.


<PRE>
mysql&#62; SELECT NOT 10;
        -&#62; 0
mysql&#62; SELECT NOT 0;
        -&#62; 1
mysql&#62; SELECT NOT NULL;
        -&#62; NULL
mysql&#62; SELECT ! (1+1);
        -&#62; 0
mysql&#62; SELECT ! 1+1;
        -&#62; 1
</PRE>

The last example produces <code>1</code> because the expression evaluates
the same way as <code>(!1)+1</code>.

<A NAME="IDX1218"></A>
<br><br><br><A NAME="IDX1219"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>AND</code></b></td>
 </tr>
</table>
<br>
<code><b>AND</b></code><DD></A>
<DT><code><b>&#38;&#38;</b></code><DD>
Logical AND.
Evaluates to <code>1</code> if all operands are non-zero and not <code>NULL</code>,
to <code>0</code> if one or more operands are <code>0</code>,
otherwise <code>NULL</code> is returned.


<PRE>
mysql&#62; SELECT 1 &#38;&#38; 1;
        -&#62; 1
mysql&#62; SELECT 1 &#38;&#38; 0;
        -&#62; 0
mysql&#62; SELECT 1 &#38;&#38; NULL;
        -&#62; NULL
mysql&#62; SELECT 0 &#38;&#38; NULL;
        -&#62; 0
mysql&#62; SELECT NULL &#38;&#38; 0;
        -&#62; 0
</PRE>

Please note that MySQL versions prior to 4.0.5 stop evaluation when
a <code>NULL</code> is encountered, rather than continuing the process to
check for possible <code>0</code> values. This means that in these versions,
<code>SELECT (NULL AND 0)</code> returns <code>NULL</code> instead of <code>0</code>.
As of MySQL 4.0.5, the code has been re-engineered so that the result is
always as prescribed by the SQL standards while still using the
optimization wherever possible.

<A NAME="IDX1220"></A>
<br><br><br><A NAME="IDX1221"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>OR</code></b></td>
 </tr>
</table>
<br>
<code><b>OR</b></code><DD></A>
<DT><code><b>||</b></code><DD>
Logical OR.
Evaluates to <code>1</code> if any operand is non-zero,
to <code>NULL</code> if any operand is <code>NULL</code>,
otherwise <code>0</code> is returned.


<PRE>
mysql&#62; SELECT 1 || 1;
        -&#62; 1
mysql&#62; SELECT 1 || 0;
        -&#62; 1
mysql&#62; SELECT 0 || 0;
        -&#62; 0
mysql&#62; SELECT 0 || NULL;
        -&#62; NULL
mysql&#62; SELECT 1 || NULL;
        -&#62; 1
</PRE>

<br><br><br><A NAME="IDX1222"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>XOR</code></b></td>
 </tr>
</table>
<br>
<code><b>XOR</b></code><DD></A>
Logical XOR.
Returns <code>NULL</code> if either operand is <code>NULL</code>.
For non-<code>NULL</code> operands, evaluates to <code>1</code> if an odd number
of operands is non-zero,
otherwise <code>0</code> is returned.


<PRE>
mysql&#62; SELECT 1 XOR 1;
        -&#62; 0
mysql&#62; SELECT 1 XOR 0;
        -&#62; 1
mysql&#62; SELECT 1 XOR NULL;
        -&#62; NULL
mysql&#62; SELECT 1 XOR 1 XOR 1;
        -&#62; 1
</PRE>

<code>a XOR b</code> is mathematically equal to
<code>(a AND (NOT b)) OR ((NOT a) and b)</code>.

<code>XOR</code> was added in MySQL 4.0.2.
</DL>



<H3><A NAME="Case_Sensitivity_Operators" HREF="index.html#Case_Sensitivity_Operators">13.1.4  Case-sensitivity Operators</A></H3>

<P>
<A NAME="IDX1223"></A>

</P>
<P>
<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>

</P>
<DL COMPACT>

<DT><code><code>BINARY</code></code>
<DD>
<A NAME="IDX1226"></A>
 
The <code>BINARY</code> operator casts the string following it to a binary string.
This is an easy way to force a column comparison to be case sensitive even
if the column isn't defined as <code>BINARY</code> or <code>BLOB</code>.


<PRE>
mysql&#62; SELECT 'a' = 'A';
        -&#62; 1
mysql&#62; SELECT BINARY 'a' = 'A';
        -&#62; 0
</PRE>

<code>BINARY str</code> is a shorthand for <code>CAST(str AS BINARY)</code>.
See section 13.7  Cast Functions.
<code>BINARY</code> was introduced in MySQL 3.23.0.

Note that in some contexts, if you cast an indexed column to <code>BINARY</code>,
MySQL will not be able to use the index efficiently.

</DL>

<P>
If you want to compare a <code>BLOB</code> value in case-insensitive fashion, you
can do so as follows:

</P>

<UL>
<LI>

Before MySQL 4.1.1, use the <code>UPPER()</code> function to convert the <code>BLOB</code>
value to uppercase before performing the comparison:


<PRE>
SELECT 'A' LIKE UPPER(blob_col) FROM tbl_name;
</PRE>

If the comparison value is lowercase, convert the <code>BLOB</code> value using
<code>LOWER()</code> instead.

<LI>

For MySQL 4.1.1 and up, <code>BLOB</code> columns have a character set of
<code>binary</code>, which has no concept of lettercase. To perform a
case-insensitive comparison, use the <code>CONVERT()</code> function to
convert the <code>BLOB</code> value to a character set that
is not case sensitive. The result is a non-binary string, so the
<code>LIKE</code> operation is not case sensitive:


<PRE>
SELECT 'A' LIKE CONVERT(blob_col USING latin1) FROM tbl_name;
</PRE>

To use a different character set, substitute its name for <code>latin1</code>
in the preceding statement.

</UL>

<P>
<code>CONVERT()</code> can be used more generally for comparing strings that
are represented in different character sets.

</P>



<H2><A NAME="Control_flow_functions" HREF="index.html#Control_flow_functions">13.2  Control Flow Functions</A></H2>

<P>
<A NAME="IDX1227"></A>
<A NAME="IDX1228"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1229"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</code></b></td>
 </tr>
</table>
<br>
<code><b>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</b></code><DD></A>
 
<DT><code><b>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</b></code><DD>
The first version returns the <code>result</code> where
<code>value=compare-value</code>. The second version returns the result for
the first condition that is true. If there was no matching result
value, the result after <code>ELSE</code> is returned, or <code>NULL</code> if there is no
<code>ELSE</code> part.


<PRE>
mysql&#62; SELECT CASE 1 WHEN 1 THEN 'one'
           WHEN 2 THEN 'two' ELSE 'more' END;
        -&#62; 'one'
mysql&#62; SELECT CASE WHEN 1&#62;0 THEN 'true' ELSE 'false' END;
        -&#62; 'true'
mysql&#62; SELECT CASE BINARY 'B'
           WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;
        -&#62; NULL
</PRE>

The type of the return value (<code>INTEGER</code>, <code>DOUBLE</code> or
<code>STRING</code>) is the same as the type of the first returned value (the
expression after the first <code>THEN</code>).

<br><br><br><A NAME="IDX1230"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>IF(expr1,expr2,expr3)</code></b></td>
 </tr>
</table>
<br>
<code><b>IF(expr1,expr2,expr3)</b></code><DD></A>
If <code>expr1</code> is TRUE (<code>expr1 &#60;&#62; 0</code> and <code>expr1 &#60;&#62; NULL</code>) then
<code>IF()</code> returns <code>expr2</code>, else it returns <code>expr3</code>.
<code>IF()</code> returns a numeric or string value, depending on the context
in which it is used.


<PRE>
mysql&#62; SELECT IF(1&#62;2,2,3);
        -&#62; 3
mysql&#62; SELECT IF(1&#60;2,'yes','no');
        -&#62; 'yes'
mysql&#62; SELECT IF(STRCMP('test','test1'),'no','yes');
        -&#62; 'no'
</PRE>

If only one of <code>expr2</code> or <code>expr3</code> is explicitly <code>NULL</code>, the
result type of the <code>IF()</code> function is the type of non-<code>NULL</code>
expression.  (This behavior is new in MySQL 4.0.3).

<code>expr1</code> is evaluated as an integer value, which means that if you are
testing floating-point or string values, you should do so using a comparison
operation.


<PRE>
mysql&#62; SELECT IF(0.1,1,0);
        -&#62; 0
mysql&#62; SELECT IF(0.1&#60;&#62;0,1,0);
        -&#62; 1
</PRE>

In the first case shown, <code>IF(0.1)</code> returns <code>0</code> because <code>0.1</code>
is converted to an integer value, resulting in a test of <code>IF(0)</code>.  This
may not be what you expect.  In the second case, the comparison tests the
original floating-point value to see whether it is non-zero.  The result
of the comparison is used as an integer.

The default return type of <code>IF()</code> (which may matter when it is
stored into a temporary table) is calculated in MySQL
3.23 as follows:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Expression</strong> </TD><TD> <strong>Return Value</strong>
</TD></TR>
<TR><TD><code>expr2</code> or <code>expr3</code> returns string </TD><TD> string
</TD></TR>
<TR><TD><code>expr2</code> or <code>expr3</code> returns a floating-point value </TD><TD> floating-point
</TD></TR>
<TR><TD><code>expr2</code> or <code>expr3</code> returns an integer </TD><TD> integer
</TD></TR>
</TABLE>

If <code>expr2</code> and <code>expr3</code> are strings, the result is case
sensitive if either string is case sensitive (starting from MySQL
3.23.51).

<A NAME="IDX1231"></A>
<br><br><br><A NAME="IDX1232"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>IFNULL(expr1,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>IFNULL(expr1,expr2)</b></code><DD></A>
If <code>expr1</code> is not <code>NULL</code>, <code>IFNULL()</code> returns <code>expr1</code>,
else it returns <code>expr2</code>.  <code>IFNULL()</code> returns a numeric or string
value, depending on the context in which it is used.


<PRE>
mysql&#62; SELECT IFNULL(1,0);
        -&#62; 1
mysql&#62; SELECT IFNULL(NULL,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,'yes');
        -&#62; 'yes'
</PRE>

In MySQL 4.0.6 and above, the default result value of
<code>IFNULL(expr1,expr2)</code> is the more ``general'' of the two expressions,
in the order <code>STRING</code>, <code>REAL</code>, or <code>INTEGER</code>. The difference
from earlier MySQL versions is mostly notable when you create a table
based on expressions or MySQL has to internally store a value from
<code>IFNULL()</code> in a temporary table.


<PRE>
CREATE TABLE tmp SELECT IFNULL(1,'test') AS test;
</PRE>

As of MySQL 4.0.6, the type for the <code>test</code> column is <code>CHAR(4)</code>,
whereas in earlier versions the type would be <code>BIGINT</code>.

<br><br><br><A NAME="IDX1233"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>NULLIF(expr1,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>NULLIF(expr1,expr2)</b></code><DD></A>
Returns <code>NULL</code> if <code>expr1 = expr2</code> is true, else returns <code>expr1</code>.
This is the same as <code>CASE WHEN x = y THEN NULL ELSE x END</code>.


<PRE>
mysql&#62; SELECT NULLIF(1,1);
        -&#62; NULL
mysql&#62; SELECT NULLIF(1,2);
        -&#62; 1
</PRE>

Note that MySQL evaluates <code>expr1</code> twice if the arguments are not equal.

</DL>



<H2><A NAME="String_functions" HREF="index.html#String_functions">13.3  String Functions</A></H2>

<P>
<A NAME="IDX1234"></A>
<A NAME="IDX1235"></A>

</P>
<P>
String-valued functions return <code>NULL</code> if the length of the result would
be greater than the value of the <code>max_allowed_packet</code> system variable.  See section 7.5.2  Tuning Server Parameters.

</P>
<P>
For functions that operate on string positions,
the first position is numbered 1.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1236"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ASCII(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>ASCII(str)</b></code><DD></A>
 
Returns the numeric value of the leftmost character of the string
<code>str</code>. Returns <code>0</code> if <code>str</code> is the empty string.  Returns
<code>NULL</code> if <code>str</code> is <code>NULL</code>.
<code>ASCII()</code> works for characters with numeric values from <code>0</code> to
<code>255</code>.


<PRE>
mysql&#62; SELECT ASCII('2');
        -&#62; 50
mysql&#62; SELECT ASCII(2);
        -&#62; 50
mysql&#62; SELECT ASCII('dx');
        -&#62; 100
</PRE>

See also the <code>ORD()</code> function.

<br><br><br><A NAME="IDX1237"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIN(N)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIN(N)</b></code><DD></A>
Returns a string representation of the binary value of <code>N</code>, where
<code>N</code> is a longlong (<code>BIGINT</code>) number.  This is equivalent to
<code>CONV(N,10,2)</code>.  Returns <code>NULL</code> if <code>N</code> is <code>NULL</code>.


<PRE>
mysql&#62; SELECT BIN(12);
        -&#62; '1100'
</PRE>

<br><br><br><A NAME="IDX1238"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIT_LENGTH(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIT_LENGTH(str)</b></code><DD></A>
Returns the length of the string <code>str</code> in bits.


<PRE>
mysql&#62; SELECT BIT_LENGTH('text');
        -&#62; 32
</PRE>

<br><br><br><A NAME="IDX1239"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CHAR(N,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>CHAR(N,...)</b></code><DD></A>
<code>CHAR()</code> interprets the arguments as integers and returns a string
consisting of the characters given by the code values of those
integers. <code>NULL</code> values are skipped.


<PRE>
mysql&#62; SELECT CHAR(77,121,83,81,'76');
        -&#62; 'MySQL'
mysql&#62; SELECT CHAR(77,77.3,'77.3');
        -&#62; 'MMM'
</PRE>

<br><br><br><A NAME="IDX1240"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CHAR_LENGTH(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>CHAR_LENGTH(str)</b></code><DD></A>
Returns the length of the string <code>str</code>, measured in characters.
A multi-byte character counts as a single character.
This means that for a string containing five two-byte characters,
<code>LENGTH()</code> returns <code>10</code>, whereas <code>CHAR_LENGTH()</code> returns
<code>5</code>.

<br><br><br><A NAME="IDX1241"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CHARACTER_LENGTH(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>CHARACTER_LENGTH(str)</b></code><DD></A>
<code>CHARACTER_LENGTH()</code> is a synonym for <code>CHAR_LENGTH()</code>.

<br><br><br><A NAME="IDX1242"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COMPRESS(string_to_compress)</code></b></td>
 </tr>
</table>
<br>
<code><b>COMPRESS(string_to_compress)</b></code><DD></A>
Compresses a string.


<PRE>
mysql&#62; SELECT LENGTH(COMPRESS(REPEAT('a',1000)));
        -&#62; 21
mysql&#62; SELECT LENGTH(COMPRESS(''));
        -&#62; 0
mysql&#62; SELECT LENGTH(COMPRESS('a'));
        -&#62; 13
mysql&#62; SELECT LENGTH(COMPRESS(REPEAT('a',16)));
        -&#62; 15
</PRE>

<code>COMPRESS()</code> was added in MySQL 4.1.1.
It requires MySQL to have been compiled with a compression library such as
<code>zlib</code>. Otherwise, the return value is always <code>NULL</code>.

The compressed string contents are stored the following way:

<UL>
<LI>

Empty strings are stored as empty strings.
<LI>

Non-empty strings are stored as a 4-byte length of the uncompressed string
(low byte first), followed by the string compressed with gzip.  If the
string ends with space, an extra <samp>`.'</samp> character is added to avoid
problems with endspace trimming should the result be stored in a <code>CHAR</code>
or <code>VARCHAR</code> column.  (Use of <code>CHAR</code> or <code>VARCHAR</code> to store
compressed strings is not recommended. It is better to use a <code>BLOB</code>
column instead.)
</UL>

<br><br><br><A NAME="IDX1243"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CONCAT(str1,str2,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>CONCAT(str1,str2,...)</b></code><DD></A>
Returns the string that results from concatenating the arguments.  Returns
<code>NULL</code> if any argument is <code>NULL</code>.  May have one or more arguments.
A numeric argument is converted to its equivalent string form.


<PRE>
mysql&#62; SELECT CONCAT('My', 'S', 'QL');
        -&#62; 'MySQL'
mysql&#62; SELECT CONCAT('My', NULL, 'QL');
        -&#62; NULL
mysql&#62; SELECT CONCAT(14.3);
        -&#62; '14.3'
</PRE>

<br><br><br><A NAME="IDX1244"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CONCAT_WS(separator, str1, str2,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>CONCAT_WS(separator, str1, str2,...)</b></code><DD></A>
<code>CONCAT_WS()</code> stands for CONCAT With Separator and is a special form of
<code>CONCAT()</code>.  The first argument is the separator for the rest of the
arguments.
The separator is added between the strings to be concatenated.
The separator can be a string as can the rest of the
arguments. If the separator is <code>NULL</code>, the result is <code>NULL</code>.
The function skips any <code>NULL</code> values after the
separator argument.


<PRE>
mysql&#62; SELECT CONCAT_WS(',',
           'First name','Second name','Last Name');
        -&#62; 'First name,Second name,Last Name'
mysql&#62; SELECT CONCAT_WS(',','First name',NULL,'Last Name');
        -&#62; 'First name,Last Name'
</PRE>

Before MySQL 4.0.14, <code>CONCAT_WS()</code> skips empty strings as well as
<code>NULL</code> values.

<br><br><br><A NAME="IDX1245"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CONV(N,from_base,to_base)</code></b></td>
 </tr>
</table>
<br>
<code><b>CONV(N,from_base,to_base)</b></code><DD></A>
Converts numbers between different number bases.  Returns a string
representation of the number <code>N</code>, converted from base <code>from_base</code>
to base <code>to_base</code>.  Returns <code>NULL</code> if any argument is <code>NULL</code>.
The argument <code>N</code> is interpreted as an integer, but may be specified as
an integer or a string.  The minimum base is <code>2</code> and the maximum base is
<code>36</code>.  If <code>to_base</code> is a negative number, <code>N</code> is regarded as a
signed number.  Otherwise, <code>N</code> is treated as unsigned.  <code>CONV()</code> works
with 64-bit precision.


<PRE>
mysql&#62; SELECT CONV('a',16,2);
        -&#62; '1010'
mysql&#62; SELECT CONV('6E',18,8);
        -&#62; '172'
mysql&#62; SELECT CONV(-17,10,-18);
        -&#62; '-H'
mysql&#62; SELECT CONV(10+'10'+'10'+0xa,10,10);
        -&#62; '40'
</PRE>

<br><br><br><A NAME="IDX1246"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ELT(N,str1,str2,str3,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>ELT(N,str1,str2,str3,...)</b></code><DD></A>
Returns <code>str1</code> if <code>N</code> = <code>1</code>, <code>str2</code> if <code>N</code> =
<code>2</code>, and so on.  Returns <code>NULL</code> if <code>N</code> is less than <code>1</code>
or greater than the number of arguments.  <code>ELT()</code> is the complement of
<code>FIELD()</code>.


<PRE>
mysql&#62; SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'ej'
mysql&#62; SELECT ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'foo'
</PRE>

<br><br><br><A NAME="IDX1247"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</code></b></td>
 </tr>
</table>
<br>
<code><b>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</b></code><DD></A>
Returns a string in which for every bit set in <code>bits</code>, you get an <code>on</code> 
string and for every reset bit you get an <code>off</code> string. Each string is 
separated by <code>separator</code> (default <samp>`,'</samp>), and only 
<code>number_of_bits</code> (default 64) of <code>bits</code> is used.


<PRE>
mysql&#62; SELECT EXPORT_SET(5,'Y','N',',',4)
        -&#62; Y,N,Y,N
</PRE>

<br><br><br><A NAME="IDX1248"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FIELD(str,str1,str2,str3,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>FIELD(str,str1,str2,str3,...)</b></code><DD></A>
Returns the index of <code>str</code> in the <code>str1</code>, <code>str2</code>,
<code>str3</code>, <code>...</code> list.
Returns <code>0</code> if <code>str</code> is not found.
<code>FIELD()</code> is the complement of <code>ELT()</code>.


<PRE>
mysql&#62; SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 2
mysql&#62; SELECT FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 0
</PRE>

<br><br><br><A NAME="IDX1249"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FIND_IN_SET(str,strlist)</code></b></td>
 </tr>
</table>
<br>
<code><b>FIND_IN_SET(str,strlist)</b></code><DD></A>
Returns a value <code>1</code> to <code>N</code> if the string <code>str</code> is in the string list
<code>strlist</code> consisting of <code>N</code> substrings. A string list is a string
composed of substrings separated by <samp>`,'</samp> characters. If the first
argument is a constant string and the second is a column of type <code>SET</code>,
the <code>FIND_IN_SET()</code> function is optimized to use bit arithmetic.
Returns <code>0</code> if <code>str</code> is not in <code>strlist</code> or if <code>strlist</code>
is the empty string.  Returns <code>NULL</code> if either argument is <code>NULL</code>.
This function will not work properly if the first argument contains a comma
(<samp>`,'</samp>) character.


<PRE>
mysql&#62; SELECT FIND_IN_SET('b','a,b,c,d');
        -&#62; 2
</PRE>

<br><br><br><A NAME="IDX1250"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>HEX(N_or_S)</code></b></td>
 </tr>
</table>
<br>
<code><b>HEX(N_or_S)</b></code><DD></A>
If <code>N_OR_S</code> is a number, returns a string representation of the hexadecimal
value of <code>N</code>, where <code>N</code> is a longlong (<code>BIGINT</code>) number.
This is equivalent to <code>CONV(N,10,16)</code>.

From MySQL 4.0.1 and up,
if <code>N_OR_S</code> is a string, returns a hexadecimal string of <code>N_OR_S</code>
where each character in <code>N_OR_S</code> is converted to two hexadecimal digits.


<PRE>
mysql&#62; SELECT HEX(255);
        -&#62; 'FF'
mysql&#62; SELECT 0x616263;
        -&#62; 'abc'
mysql&#62; SELECT HEX('abc');
        -&#62; 616263
</PRE>

<br><br><br><A NAME="IDX1251"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>INSERT(str,pos,len,newstr)</code></b></td>
 </tr>
</table>
<br>
<code><b>INSERT(str,pos,len,newstr)</b></code><DD></A>
Returns the string <code>str</code>, with the substring beginning at position
<code>pos</code> and <code>len</code> characters long replaced by the string
<code>newstr</code>.


<PRE>
mysql&#62; SELECT INSERT('Quadratic', 3, 4, 'What');
        -&#62; 'QuWhattic'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1252"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>INSTR(str,substr)</code></b></td>
 </tr>
</table>
<br>
<code><b>INSTR(str,substr)</b></code><DD></A>
Returns the position of the first occurrence of substring <code>substr</code> in
string <code>str</code>. This is the same as the two-argument form of
<code>LOCATE()</code>, except that the arguments are swapped.


<PRE>
mysql&#62; SELECT INSTR('foobarbar', 'bar');
        -&#62; 4
mysql&#62; SELECT INSTR('xbar', 'foobar');
        -&#62; 0
</PRE>

This function is multi-byte safe.  In MySQL 3.23, this function is case
sensitive. For 4.0 on, it is case sensitive only if either argument is a
binary string.

<br><br><br><A NAME="IDX1253"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LCASE(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>LCASE(str)</b></code><DD></A>
<code>LCASE()</code> is a synonym for <code>LOWER()</code>.

<br><br><br><A NAME="IDX1254"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LEFT(str,len)</code></b></td>
 </tr>
</table>
<br>
<code><b>LEFT(str,len)</b></code><DD></A>
Returns the leftmost <code>len</code> characters from the string <code>str</code>.


<PRE>
mysql&#62; SELECT LEFT('foobarbar', 5);
        -&#62; 'fooba'
</PRE>

<br><br><br><A NAME="IDX1255"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LENGTH(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>LENGTH(str)</b></code><DD></A>
Returns the length of the string <code>str</code>, measured in bytes.
A multi-byte character counts as multiple bytes.
This means that for a string containing five two-byte characters,
<code>LENGTH()</code> returns <code>10</code>, whereas <code>CHAR_LENGTH()</code> returns
<code>5</code>.


<PRE>
mysql&#62; SELECT LENGTH('text');
        -&#62; 4
</PRE>

<A NAME="IDX1256"></A>
<br><br><br><A NAME="IDX1257"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOAD_FILE(file_name)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOAD_FILE(file_name)</b></code><DD></A>
Reads the file and returns the file contents as a string.  The file
must be located on the server, you must specify the full pathname to the
file, and you must have the <code>FILE</code> privilege.  The file must
be readable by all and be smaller than <code>max_allowed_packet</code> bytes.

If the file doesn't exist or can't be read because one of the preceding
conditions is not satisfied, the function returns <code>NULL</code>.


<PRE>
mysql&#62; UPDATE tbl_name
           SET blob_column=LOAD_FILE('/tmp/picture')
           WHERE id=1;
</PRE>

Before MySQL 3.23, you must read the file inside your application and create
an <code>INSERT</code> statement to update the database with the file contents.
If you are using the MySQL++ library, one way to do this can be found at
http://www.mysql.com/documentation/mysql++/mysql++-examples.html.

<br><br><br><A NAME="IDX1258"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOCATE(substr,str)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOCATE(substr,str)</b></code><DD></A>
<DT><code><b>LOCATE(substr,str,pos)</b></code><DD>
The first syntax
returns the position of the first occurrence of substring <code>substr</code>
in string <code>str</code>.
The second syntax
returns the position of the first occurrence of substring <code>substr</code> in
string <code>str</code>, starting at position <code>pos</code>.
Returns <code>0</code> if <code>substr</code> is not in <code>str</code>.


<PRE>
mysql&#62; SELECT LOCATE('bar', 'foobarbar');
        -&#62; 4
mysql&#62; SELECT LOCATE('xbar', 'foobar');
        -&#62; 0
mysql&#62; SELECT LOCATE('bar', 'foobarbar',5);
        -&#62; 7
</PRE>

This function is multi-byte safe.  In MySQL 3.23, this function is case
sensitive. For 4.0 on, it is case sensitive only if either argument is a
binary string.

<br><br><br><A NAME="IDX1259"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOWER(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOWER(str)</b></code><DD></A>
Returns the string <code>str</code> with all characters changed to lowercase
according to the current character set mapping (the default is ISO-8859-1
Latin1).


<PRE>
mysql&#62; SELECT LOWER('QUADRATICALLY');
        -&#62; 'quadratically'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1260"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LPAD(str,len,padstr)</code></b></td>
 </tr>
</table>
<br>
<code><b>LPAD(str,len,padstr)</b></code><DD></A>
Returns the string <code>str</code>, left-padded with the string <code>padstr</code>
to a length of <code>len</code> characters. If <code>str</code> is longer
than <code>len</code>, the return value is shortened to <code>len</code> characters.


<PRE>
mysql&#62; SELECT LPAD('hi',4,'??');
        -&#62; '??hi'
mysql&#62; SELECT LPAD('hi',1,'??');
        -&#62; 'h'
</PRE>

<br><br><br><A NAME="IDX1261"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LTRIM(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>LTRIM(str)</b></code><DD></A>
Returns the string <code>str</code> with leading space characters removed.


<PRE>
mysql&#62; SELECT LTRIM('  barbar');
        -&#62; 'barbar'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1262"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MAKE_SET(bits,str1,str2,...)</code></b></td>
 </tr>
</table>
<br>
<code><b>MAKE_SET(bits,str1,str2,...)</b></code><DD></A>
Returns a set value (a string containing substrings separated by <samp>`,'</samp>
characters) consisting of the strings that have the corresponding bit in
<code>bits</code> set.  <code>str1</code> corresponds to bit 0, <code>str2</code> to bit 1,
and so on.  <code>NULL</code> strings in <code>str1</code>, <code>str2</code>, <code>...</code>
are not appended to the result.


<PRE>
mysql&#62; SELECT MAKE_SET(1,'a','b','c');
        -&#62; 'a'
mysql&#62; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&#62; 'hello,world'
mysql&#62; SELECT MAKE_SET(1 | 4,'hello','nice',NULL,'world');
        -&#62; 'hello'
mysql&#62; SELECT MAKE_SET(0,'a','b','c');
        -&#62; ''
</PRE>

<br><br><br><A NAME="IDX1263"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MID(str,pos,len)</code></b></td>
 </tr>
</table>
<br>
<code><b>MID(str,pos,len)</b></code><DD></A>
<code>MID(str,pos,len)</code> is a synonym for <code>SUBSTRING(str,pos,len)</code>.

<br><br><br><A NAME="IDX1264"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>OCT(N)</code></b></td>
 </tr>
</table>
<br>
<code><b>OCT(N)</b></code><DD></A>
Returns a string representation of the octal value of <code>N</code>, where
<code>N</code> is a longlong number.  This is equivalent to <code>CONV(N,10,8)</code>.
Returns <code>NULL</code> if <code>N</code> is <code>NULL</code>.


<PRE>
mysql&#62; SELECT OCT(12);
        -&#62; '14'
</PRE>

<br><br><br><A NAME="IDX1265"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>OCTET_LENGTH(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>OCTET_LENGTH(str)</b></code><DD></A>
<code>OCTET_LENGTH()</code> is a synonym for <code>LENGTH()</code>.

<br><br><br><A NAME="IDX1266"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ORD(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>ORD(str)</b></code><DD></A>
If the leftmost character of the string <code>str</code> is a multi-byte character,
returns the code for that character, calculated from the numeric values
of its constituent bytes using this formula:


<PRE>
  (1st byte code * 256)
+ (2nd byte code * 256^2)
+ (3rd byte code * 256^3) ...
</PRE>

If the leftmost character is not a multi-byte character, <code>ORD()</code>
returns the same value that the <code>ASCII()</code> function does.


<PRE>
mysql&#62; SELECT ORD('2');
        -&#62; 50
</PRE>

<br><br><br><A NAME="IDX1267"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>POSITION(substr IN str)</code></b></td>
 </tr>
</table>
<br>
<code><b>POSITION(substr IN str)</b></code><DD></A>
<code>POSITION(substr IN str)</code> is a synonym for <code>LOCATE(substr,str)</code>.

<br><br><br><A NAME="IDX1268"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>QUOTE(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>QUOTE(str)</b></code><DD></A>
Quotes a string to produce a result that can be used as a properly escaped
data value in an SQL statement.  The string is returned surrounded by single
quotes and with each instance of single quote (<samp>`''</samp>), backslash (<samp>`\'</samp>),
ASCII NUL, and Control-Z preceded by a backslash.  If the argument is
<code>NULL</code>, the return value is the word ``NULL'' without surrounding
single quotes.
The <code>QUOTE()</code> function was added in MySQL 4.0.3.


<PRE>
mysql&#62; SELECT QUOTE('Don\'t');
        -&#62; 'Don\'t!'
mysql&#62; SELECT QUOTE(NULL);
        -&#62; NULL
</PRE>

<br><br><br><A NAME="IDX1269"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>REPEAT(str,count)</code></b></td>
 </tr>
</table>
<br>
<code><b>REPEAT(str,count)</b></code><DD></A>
Returns a string consisting of the string <code>str</code> repeated <code>count</code>
times. If <code>count &#60;= 0</code>, returns an empty string. Returns <code>NULL</code> if
<code>str</code> or <code>count</code> are <code>NULL</code>.


<PRE>
mysql&#62; SELECT REPEAT('MySQL', 3);
        -&#62; 'MySQLMySQLMySQL'
</PRE>

<br><br><br><A NAME="IDX1270"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>REPLACE(str,from_str,to_str)</code></b></td>
 </tr>
</table>
<br>
<code><b>REPLACE(str,from_str,to_str)</b></code><DD></A>
Returns the string <code>str</code> with all occurrences of the string
<code>from_str</code> replaced by the string <code>to_str</code>.


<PRE>
mysql&#62; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&#62; 'WwWwWw.mysql.com'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1271"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>REVERSE(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>REVERSE(str)</b></code><DD></A>
Returns the string <code>str</code> with the order of the characters reversed.


<PRE>
mysql&#62; SELECT REVERSE('abc');
        -&#62; 'cba'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1272"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RIGHT(str,len)</code></b></td>
 </tr>
</table>
<br>
<code><b>RIGHT(str,len)</b></code><DD></A>
Returns the rightmost <code>len</code> characters from the string <code>str</code>.


<PRE>
mysql&#62; SELECT RIGHT('foobarbar', 4);
        -&#62; 'rbar'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1273"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RPAD(str,len,padstr)</code></b></td>
 </tr>
</table>
<br>
<code><b>RPAD(str,len,padstr)</b></code><DD></A>
Returns the string <code>str</code>, right-padded with the string <code>padstr</code>
to a length of <code>len</code> characters. If <code>str</code> is longer
than <code>len</code>, the return value is shortened to <code>len</code> characters.


<PRE>
mysql&#62; SELECT RPAD('hi',5,'?');
        -&#62; 'hi???'
mysql&#62; SELECT RPAD('hi',1,'?');
        -&#62; 'h'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1274"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RTRIM(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>RTRIM(str)</b></code><DD></A>
Returns the string <code>str</code> with trailing space characters removed.


<PRE>
mysql&#62; SELECT RTRIM('barbar   ');
        -&#62; 'barbar'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1275"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SOUNDEX(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>SOUNDEX(str)</b></code><DD></A>
Returns a soundex string from <code>str</code>. Two strings that sound almost the
same should have identical soundex strings. A standard soundex string
is 4 characters long, but the <code>SOUNDEX()</code> function returns an
arbitrarily long string. You can use <code>SUBSTRING()</code> on the result to get
a standard soundex string.  All non-alphabetic characters are ignored in the
given string. All international alphabetic characters outside the A-Z range
are treated as vowels.


<PRE>
mysql&#62; SELECT SOUNDEX('Hello');
        -&#62; 'H400'
mysql&#62; SELECT SOUNDEX('Quadratically');
        -&#62; 'Q36324'
</PRE>

<strong>Note:</strong> this function implements the original Soundex algorithm,
not the more popular enhanced version (also described by D. Knuth).
The difference is that original version discards vowels first and then
duplicates, whereas the enhanced discards duplicates first and vowels.

<br><br><br><A NAME="IDX1276"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr1 SOUNDS LIKE expr2</code></b></td>
 </tr>
</table>
<br>
<code><b>expr1 SOUNDS LIKE expr2</b></code><DD></A>
This is the same as <code>SOUNDEX(expr1)=SOUNDEX(expr2)</code> (available only in MySQL 4.1 or later). 

<br><br><br><A NAME="IDX1277"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SPACE(N)</code></b></td>
 </tr>
</table>
<br>
<code><b>SPACE(N)</b></code><DD></A>
Returns a string consisting of <code>N</code> space characters.


<PRE>
mysql&#62; SELECT SPACE(6);
        -&#62; '      '
</PRE>

<br><br><br><A NAME="IDX1278"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SUBSTRING(str,pos)</code></b></td>
 </tr>
</table>
<br>
<code><b>SUBSTRING(str,pos)</b></code><DD></A>
<DT><code><b>SUBSTRING(str FROM pos)</b></code><DD>
<DT><code><b>SUBSTRING(str,pos,len)</b></code><DD>
<DT><code><b>SUBSTRING(str FROM pos FOR len)</b></code><DD>
The forms without a <code>len</code> argument
return a substring from string <code>str</code> starting at position <code>pos</code>.
The forms with a <code>len</code> argument
return a substring <code>len</code> characters long from string <code>str</code>,
starting at position <code>pos</code>.
The forms that use <code>FROM</code> are SQL-92 syntax.


<PRE>
mysql&#62; SELECT SUBSTRING('Quadratically',5);
        -&#62; 'ratically'
mysql&#62; SELECT SUBSTRING('foobarbar' FROM 4);
        -&#62; 'barbar'
mysql&#62; SELECT SUBSTRING('Quadratically',5,6);
        -&#62; 'ratica'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1279"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SUBSTRING_INDEX(str,delim,count)</code></b></td>
 </tr>
</table>
<br>
<code><b>SUBSTRING_INDEX(str,delim,count)</b></code><DD></A>
Returns the substring from string <code>str</code> before <code>count</code>
occurrences of the delimiter <code>delim</code>.
If <code>count</code> is positive, everything to the left of the final delimiter
(counting from the left) is returned.
If <code>count</code> is negative, everything to the right of the final delimiter
(counting from the right) is returned.


<PRE>
mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&#62; 'www.mysql'
mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&#62; 'mysql.com'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1280"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</code></b></td>
 </tr>
</table>
<br>
<code><b>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</b></code><DD></A>
Returns the string <code>str</code> with all <code>remstr</code> prefixes and/or suffixes
removed. If none of the specifiers <code>BOTH</code>, <code>LEADING</code> or
<code>TRAILING</code> is given, <code>BOTH</code> is assumed. If <code>remstr</code> is not
specified, spaces are removed.


<PRE>
mysql&#62; SELECT TRIM('  bar   ');
        -&#62; 'bar'
mysql&#62; SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&#62; 'barxxx'
mysql&#62; SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&#62; 'bar'
mysql&#62; SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&#62; 'barx'
</PRE>

This function is multi-byte safe.

<br><br><br><A NAME="IDX1281"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UCASE(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>UCASE(str)</b></code><DD></A>
<code>UCASE()</code> is a synonym for <code>UPPER()</code>.

<br><br><br><A NAME="IDX1282"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UNCOMPRESS(string_to_uncompress)</code></b></td>
 </tr>
</table>
<br>
<code><b>UNCOMPRESS(string_to_uncompress)</b></code><DD></A>
Uncompresses a string compressed by the <code>COMPRESS()</code> function.
If the argument is not a compressed value, the result is <code>NULL</code>.


<PRE>
mysql&#62; SELECT UNCOMPRESS(COMPRESS('any string'));
        -&#62; 'any string'
mysql&#62; SELECT UNCOMPRESS('any string');
        -&#62; NULL
</PRE>

<code>UNCOMPRESS()</code> was added in MySQL 4.1.1.
It requires MySQL to have been compiled with a compression library such as
<code>zlib</code>. Otherwise, the return value is always <code>NULL</code>.

<br><br><br><A NAME="IDX1283"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UNCOMPRESSED_LENGTH(compressed_string)</code></b></td>
 </tr>
</table>
<br>
<code><b>UNCOMPRESSED_LENGTH(compressed_string)</b></code><DD></A>
Returns the length of a compressed string before compression.


<PRE>
mysql&#62; SELECT UNCOMPRESSED_LENGTH(COMPRESS(REPEAT('a',30)));
        -&#62; 30
</PRE>

<code>UNCOMPRESSED_LENGTH()</code> was added in MySQL 4.1.1.

<br><br><br><A NAME="IDX1284"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UNHEX(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>UNHEX(str)</b></code><DD></A>
Does the opposite of <code>HEX(string)</code>. That is, it interprets each pair of
hexadecimal digits in the argument as a number and converts it to the
character represented by the number. The resulting characters are returned as
a binary string.


<PRE>
mysql&#62; SELECT UNHEX('4D7953514C');
        -&#62; 'MySQL'
mysql&#62; SELECT 0x4D7953514C;
        -&#62; 'MySQL'
mysql&#62; SELECT UNHEX(HEX('string'));
        -&#62; 'string'
mysql&#62; SELECT HEX(UNHEX('1267'));
        -&#62; '1267'
</PRE>

<code>UNHEX()</code> was added in MySQL 4.1.2.

<br><br><br><A NAME="IDX1285"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UPPER(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>UPPER(str)</b></code><DD></A>
Returns the string <code>str</code> with all characters changed to uppercase
according to the current character set mapping (the default is ISO-8859-1
Latin1).


<PRE>
mysql&#62; SELECT UPPER('Hej');
        -&#62; 'HEJ'
</PRE>

This function is multi-byte safe.

</DL>



<H3><A NAME="String_comparison_functions" HREF="index.html#String_comparison_functions">13.3.1  String Comparison Functions</A></H3>

<P>
<A NAME="IDX1286"></A>
<A NAME="IDX1287"></A>

</P>
<P>
MySQL automatically converts numbers to strings as necessary, and
vice-versa.

</P>

<PRE>
mysql&#62; SELECT 1+'1';
        -&#62; 2
mysql&#62; SELECT CONCAT(2,' test');
        -&#62; '2 test'
</PRE>

<P>
If you want to convert a number to a string explicitly, use the <code>CAST()</code>
or <code>CONCAT()</code> function:

</P>

<PRE>
mysql&#62; SELECT 38.8, CAST(38.8 AS CHAR);
        -&#62; 38.8, '38.8'
mysql&#62; SELECT 38.8, CONCAT(38.8);
        -&#62; 38.8, '38.8'
</PRE>

<P>
<code>CAST()</code> is preferable, but it is unavailable before MySQL 4.0.2.

</P>
<P>
If a string function is given a binary string as an argument, the resulting
string is also a binary string.  A number converted to a string is treated as
a binary string.  This only affects comparisons.

</P>
<P>
<A NAME="IDX1288"></A>
<A NAME="IDX1289"></A>

</P>
<P>
Normally, if any expression in a string comparison is case sensitive, the
comparison is performed in case-sensitive fashion.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1290"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr LIKE pat [ESCAPE 'escape-char']</code></b></td>
 </tr>
</table>
<br>
<code><b>expr LIKE pat [ESCAPE 'escape-char']</b></code><DD></A>
 
Pattern matching using
SQL simple regular expression comparison. Returns <code>1</code> (TRUE) or <code>0</code>
(FALSE).  If either <code>expr</code> or <code>pat</code> is <code>NULL</code>, the result is
<code>NULL</code>.

With <code>LIKE</code> you can use the following two wildcard characters
in the pattern:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Character</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD><code>%</code> </TD><TD> Matches any number of characters, even zero characters
</TD></TR>
<TR><TD><code>_</code> </TD><TD> Matches exactly one character
</TD></TR>
</TABLE>


<PRE>
mysql&#62; SELECT 'David!' LIKE 'David_';
        -&#62; 1
mysql&#62; SELECT 'David!' LIKE '%D%v%';
        -&#62; 1
</PRE>

To test for literal instances of a wildcard character, precede the character
with the escape character.  If you don't specify the <code>ESCAPE</code> character,
<samp>`\'</samp> is assumed.

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>String</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD><code>\%</code> </TD><TD> Matches one <samp>`%'</samp> character
</TD></TR>
<TR><TD><code>\_</code> </TD><TD> Matches one <samp>`_'</samp> character
</TD></TR>
</TABLE>


<PRE>
mysql&#62; SELECT 'David!' LIKE 'David\_';
        -&#62; 0
mysql&#62; SELECT 'David_' LIKE 'David\_';
        -&#62; 1
</PRE>

To specify a different escape character, use the <code>ESCAPE</code> clause:


<PRE>
mysql&#62; SELECT 'David_' LIKE 'David|_' ESCAPE '|';
        -&#62; 1
</PRE>

The following two statements illustrate that string comparisons are
not case sensitive unless one of the operands is a binary string:


<PRE>
mysql&#62; SELECT 'abc' LIKE 'ABC';
        -&#62; 1
mysql&#62; SELECT 'abc' LIKE BINARY 'ABC';
        -&#62; 0
</PRE>

In MySQL, <code>LIKE</code> is allowed on numeric expressions. (This is an
extension to the SQL-99 <code>LIKE</code>.)


<PRE>
mysql&#62; SELECT 10 LIKE '1%';
        -&#62; 1
</PRE>

Note: Because MySQL uses the C escape syntax in strings (for example,
<samp>`\n'</samp> to represent newline), you must double any <samp>`\'</samp> that you use in your <code>LIKE</code>
strings.  For example, to search for <samp>`\n'</samp>, specify it as <samp>`\\n'</samp>.  To
search for <samp>`\'</samp>, specify it as <samp>`\\\\'</samp> (the backslashes are stripped
once by the parser and another time when the pattern match is done, leaving
a single backslash to be matched).

<strong>Note:</strong> Currently <code>LIKE</code> is not multi-byte character safe.
Comparison is done character by character.

<br><br><br><A NAME="IDX1291"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr NOT LIKE pat [ESCAPE 'escape-char']</code></b></td>
 </tr>
</table>
<br>
<code><b>expr NOT LIKE pat [ESCAPE 'escape-char']</b></code><DD></A>
This is the same as <code>NOT (expr LIKE pat [ESCAPE 'escape-char'])</code>.

<br><br><br><A NAME="IDX1292"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr NOT REGEXP pat</code></b></td>
 </tr>
</table>
<br>
<code><b>expr NOT REGEXP pat</b></code><DD></A>
<DT><code><b>expr NOT RLIKE pat</b></code><DD>
This is the same as <code>NOT (expr REGEXP pat)</code>.

<A NAME="IDX1293"></A>
<A NAME="IDX1294"></A>
<A NAME="IDX1295"></A>
<br><br><br><A NAME="IDX1296"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>expr REGEXP pat</code></b></td>
 </tr>
</table>
<br>
<code><b>expr REGEXP pat</b></code><DD></A>
<DT><code><b>expr RLIKE pat</b></code><DD>
Performs a pattern match of a string expression <code>expr</code> against a pattern
<code>pat</code>.  The pattern can be an extended regular expression.
The syntax for regular expressions is discussed in
section F  MySQL Regular Expressions.  Returns <code>1</code> if <code>expr</code> matches <code>pat</code>, otherwise
returns <code>0</code>.  If either <code>expr</code> or <code>pat</code> is <code>NULL</code>,
the result is <code>NULL</code>.  <code>RLIKE</code> is a synonym for <code>REGEXP</code>,
provided for
<code>mSQL</code> compatibility. Note: Because MySQL uses the C escape
syntax in strings (for example, <samp>`\n'</samp> to represent newline), you must double any <samp>`\'</samp> that
you use in your <code>REGEXP</code> strings.  As of MySQL 3.23.4,
<code>REGEXP</code> is not case sensitive for normal (not binary) strings.


<PRE>
mysql&#62; SELECT 'Monty!' REGEXP 'm%y%%';
        -&#62; 0
mysql&#62; SELECT 'Monty!' REGEXP '.*';
        -&#62; 1
mysql&#62; SELECT 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&#62; 1
mysql&#62; SELECT 'a' REGEXP 'A', 'a' REGEXP BINARY 'A';
        -&#62; 1  0
mysql&#62; SELECT 'a' REGEXP '^[a-d]';
        -&#62; 1
</PRE>

<code>REGEXP</code> and <code>RLIKE</code> use the current character set (ISO-8859-1
Latin1 by default) when deciding the type of a character.

<br><br><br><A NAME="IDX1297"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>STRCMP(expr1,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>STRCMP(expr1,expr2)</b></code><DD></A>
<code>STRCMP()</code>
returns <code>0</code> if the strings are the same, <code>-1</code> if the first
argument is smaller than the second according to the current sort order,
and <code>1</code> otherwise.


<PRE>
mysql&#62; SELECT STRCMP('text', 'text2');
        -&#62; -1
mysql&#62; SELECT STRCMP('text2', 'text');
        -&#62; 1
mysql&#62; SELECT STRCMP('text', 'text');
        -&#62; 0
</PRE>

As of MySQL 4.0,
<code>STRCMP()</code> uses the current character set when performing comparisons.
This makes the default comparison behavior case insensitive unless
one or both of the operands are binary strings.
Before MySQL 4.0, <code>STRCMP()</code> is case sensitive.

</DL>



<H2><A NAME="Numeric_Functions" HREF="index.html#Numeric_Functions">13.4  Numeric Functions</A></H2>



<H3><A NAME="Arithmetic_functions" HREF="index.html#Arithmetic_functions">13.4.1  Arithmetic Operators</A></H3>

<P>
<A NAME="IDX1298"></A>
The usual arithmetic operators are available. Note that in the case of
<samp>`-'</samp>, <samp>`+'</samp>, and <samp>`*'</samp>, the result is calculated with
<code>BIGINT</code> (64-bit) precision if both arguments are integers.
If one of the argument is an unsigned integer, and the other argument
is also an integer, the result will be an unsigned integer.
See section 13.7  Cast Functions.

</P>
<P>
<A NAME="IDX1299"></A>
<A NAME="IDX1300"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1301"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>+</code></b></td>
 </tr>
</table>
<br>
<code><b>+</b></code><DD></A>
 <A NAME="IDX1302"></A>
 
Addition:


<PRE>
mysql&#62; SELECT 3+5;
        -&#62; 8
</PRE>

<A NAME="IDX1303"></A>
<br><br><br><A NAME="IDX1304"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>-</code></b></td>
 </tr>
</table>
<br>
<code><b>-</b></code><DD></A>
Subtraction:


<PRE>
mysql&#62; SELECT 3-5;
        -&#62; -2
</PRE>

<A NAME="IDX1305"></A>
<A NAME="IDX1306"></A>
<br><br><br><A NAME="IDX1307"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>-</code></b></td>
 </tr>
</table>
<br>
<code><b>-</b></code><DD></A>
Unary minus. Changes the sign of the argument.


<PRE>
mysql&#62; SELECT - 2;
        -&#62; -2
</PRE>

Note that if this operator is used with a <code>BIGINT</code>, the return value is a
<code>BIGINT</code>!  This means that you should avoid using <code>-</code> on integers that
may have the value of <code>-2^63</code>!

<A NAME="IDX1308"></A>
<br><br><br><A NAME="IDX1309"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>*</code></b></td>
 </tr>
</table>
<br>
<code><b>*</b></code><DD></A>
Multiplication:


<PRE>
mysql&#62; SELECT 3*5;
        -&#62; 15
mysql&#62; SELECT 18014398509481984*18014398509481984.0;
        -&#62; 324518553658426726783156020576256.0
mysql&#62; SELECT 18014398509481984*18014398509481984;
        -&#62; 0
</PRE>

The result of the last expression is incorrect because the result of the
integer multiplication exceeds the 64-bit range of <code>BIGINT</code>
calculations.

<A NAME="IDX1310"></A>
<br><br><br><A NAME="IDX1311"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>/</code></b></td>
 </tr>
</table>
<br>
<code><b>/</b></code><DD></A>
Division:


<PRE>
mysql&#62; SELECT 3/5;
        -&#62; 0.60
</PRE>

Division by zero produces a <code>NULL</code> result:


<PRE>
mysql&#62; SELECT 102/(1-1);
        -&#62; NULL
</PRE>

A division will be calculated with <code>BIGINT</code> arithmetic only if performed
in a context where its result is converted to an integer!

</DL>



<H3><A NAME="Mathematical_functions" HREF="index.html#Mathematical_functions">13.4.2  Mathematical Functions</A></H3>
<P>
All mathematical functions return <code>NULL</code> in case of an error.

</P>
<P>
<A NAME="IDX1312"></A>
<A NAME="IDX1313"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1314"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ABS(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ABS(X)</b></code><DD></A>
 
Returns the absolute value of <code>X</code>.


<PRE>
mysql&#62; SELECT ABS(2);
        -&#62; 2
mysql&#62; SELECT ABS(-32);
        -&#62; 32
</PRE>

This function is safe to use with <code>BIGINT</code> values.

<br><br><br><A NAME="IDX1315"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ACOS(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ACOS(X)</b></code><DD></A>
Returns the arc cosine of <code>X</code>, that is, the value whose cosine is
<code>X</code>. Returns <code>NULL</code> if <code>X</code> is not in the range <code>-1</code> to
<code>1</code>.


<PRE>
mysql&#62; SELECT ACOS(1);
        -&#62; 0.000000
mysql&#62; SELECT ACOS(1.0001);
        -&#62; NULL
mysql&#62; SELECT ACOS(0);
        -&#62; 1.570796
</PRE>

<br><br><br><A NAME="IDX1316"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ASIN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ASIN(X)</b></code><DD></A>
Returns the arc sine of <code>X</code>, that is, the value whose sine is
<code>X</code>. Returns <code>NULL</code> if <code>X</code> is not in the range <code>-1</code> to
<code>1</code>.


<PRE>
mysql&#62; SELECT ASIN(0.2);
        -&#62; 0.201358
mysql&#62; SELECT ASIN('foo');
        -&#62; 0.000000
</PRE>

<br><br><br><A NAME="IDX1317"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ATAN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ATAN(X)</b></code><DD></A>
Returns the arc tangent of <code>X</code>, that is, the value whose tangent is
<code>X</code>.


<PRE>
mysql&#62; SELECT ATAN(2);
        -&#62; 1.107149
mysql&#62; SELECT ATAN(-2);
        -&#62; -1.107149
</PRE>

<br><br><br><A NAME="IDX1318"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ATAN(Y,X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ATAN(Y,X)</b></code><DD></A>
<DT><code><b>ATAN2(Y,X)</b></code><DD>
Returns the arc tangent of the two variables <code>X</code> and <code>Y</code>. It is
similar to calculating the arc tangent of <code>Y / X</code>, except that the
signs of both arguments are used to determine the quadrant of the
result.


<PRE>
mysql&#62; SELECT ATAN(-2,2);
        -&#62; -0.785398
mysql&#62; SELECT ATAN2(PI(),0);
        -&#62; 1.570796
</PRE>

<br><br><br><A NAME="IDX1319"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CEILING(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>CEILING(X)</b></code><DD></A>
<DT><code><b>CEIL(X)</b></code><DD>
Returns the smallest integer value not less than <code>X</code>.


<PRE>
mysql&#62; SELECT CEILING(1.23);
        -&#62; 2
mysql&#62; SELECT CEIL(-1.23);
        -&#62; -1
</PRE>

The <code>CEIL()</code> alias was added in MySQL 4.0.6.

Note that the return value is converted to a <code>BIGINT</code>!

<br><br><br><A NAME="IDX1320"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COS(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>COS(X)</b></code><DD></A>
Returns the cosine of <code>X</code>, where <code>X</code> is given in radians.


<PRE>
mysql&#62; SELECT COS(PI());
        -&#62; -1.000000
</PRE>

<br><br><br><A NAME="IDX1321"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COT(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>COT(X)</b></code><DD></A>
Returns the cotangent of <code>X</code>.


<PRE>
mysql&#62; SELECT COT(12);
        -&#62; -1.57267341
mysql&#62; SELECT COT(0);
        -&#62; NULL
</PRE>

<br><br><br><A NAME="IDX1322"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CRC32(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>CRC32(expr)</b></code><DD></A>
Computes a cyclic redundancy check value and returns a 32-bit unsigned value.
The result is <code>NULL</code> if the argument is <code>NULL</code>.
The argument is expected be a string and will be treated as one if it is not.


<PRE>
mysql&#62; SELECT CRC32('MySQL');
        -&#62; 3259397556
</PRE>

<code>CRC32()</code> is available as of MySQL 4.1.0.

<br><br><br><A NAME="IDX1323"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DEGREES(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>DEGREES(X)</b></code><DD></A>
Returns the argument <code>X</code>, converted from radians to degrees.


<PRE>
mysql&#62; SELECT DEGREES(PI());
        -&#62; 180.000000
</PRE>

<br><br><br><A NAME="IDX1324"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DIV</code></b></td>
 </tr>
</table>
<br>
<code><b>DIV</b></code><DD></A>
Integer division.
Similar to <code>FLOOR()</code> but safe with <code>BIGINT</code> values.


<PRE>
mysql&#62; SELECT 5 DIV 2
        -&#62; 2
</PRE>

<code>DIV</code> is new in MySQL 4.1.0.

<br><br><br><A NAME="IDX1325"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>EXP(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>EXP(X)</b></code><DD></A>
Returns the value of <code>e</code> (the base of natural logarithms) raised to
the power of <code>X</code>.


<PRE>
mysql&#62; SELECT EXP(2);
        -&#62; 7.389056
mysql&#62; SELECT EXP(-2);
        -&#62; 0.135335
</PRE>

<br><br><br><A NAME="IDX1326"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FLOOR(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>FLOOR(X)</b></code><DD></A>
Returns the largest integer value not greater than <code>X</code>.


<PRE>
mysql&#62; SELECT FLOOR(1.23);
        -&#62; 1
mysql&#62; SELECT FLOOR(-1.23);
        -&#62; -2
</PRE>

Note that the return value is converted to a <code>BIGINT</code>!

<br><br><br><A NAME="IDX1327"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>LN(X)</b></code><DD></A>
Returns the natural logarithm of <code>X</code>.


<PRE>
mysql&#62; SELECT LN(2);
        -&#62; 0.693147
mysql&#62; SELECT LN(-2);
        -&#62; NULL
</PRE>

This function was added in MySQL 4.0.3.
It is synonymous with <code>LOG(X)</code> in MySQL.

<br><br><br><A NAME="IDX1328"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOG(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOG(X)</b></code><DD></A>
<DT><code><b>LOG(B,X)</b></code><DD>
If called with one parameter, this function returns the natural logarithm
of <code>X</code>.


<PRE>
mysql&#62; SELECT LOG(2);
        -&#62; 0.693147
mysql&#62; SELECT LOG(-2);
        -&#62; NULL
</PRE>

If called with two parameters, this function returns the logarithm of
<code>X</code> for an arbitrary base <code>B</code>.

<PRE>
mysql&#62; SELECT LOG(2,65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG(1,100);
        -&#62; NULL
</PRE>

The arbitrary base option was added in MySQL 4.0.3.
<code>LOG(B,X)</code> is equivalent to <code>LOG(X)/LOG(B)</code>.

<br><br><br><A NAME="IDX1329"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOG2(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOG2(X)</b></code><DD></A>
Returns the base-2 logarithm of <code>X</code>.


<PRE>
mysql&#62; SELECT LOG2(65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG2(-100);
        -&#62; NULL
</PRE>

<code>LOG2()</code> is useful for finding out how many bits a number would
require for storage.
This function was added in MySQL 4.0.3.
In earlier versions, you can use <code>LOG(X)/LOG(2)</code> instead.

<br><br><br><A NAME="IDX1330"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOG10(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>LOG10(X)</b></code><DD></A>
Returns the base-10 logarithm of <code>X</code>.


<PRE>
mysql&#62; SELECT LOG10(2);
        -&#62; 0.301030
mysql&#62; SELECT LOG10(100);
        -&#62; 2.000000
mysql&#62; SELECT LOG10(-100);
        -&#62; NULL
</PRE>

<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
<A NAME="IDX1333"></A>
<A NAME="IDX1334"></A>
<br><br><br><A NAME="IDX1335"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MOD(N,M)</code></b></td>
 </tr>
</table>
<br>
<code><b>MOD(N,M)</b></code><DD></A>
<DT><code><b>N % M</b></code><DD>
<DT><code><b>N MOD M</b></code><DD>
Modulo (like the <code>%</code> operator in C).
Returns the remainder of <code>N</code> divided by <code>M</code>.


<PRE>
mysql&#62; SELECT MOD(234, 10);
        -&#62; 4
mysql&#62; SELECT 253 % 7;
        -&#62; 1
mysql&#62; SELECT MOD(29,9);
        -&#62; 2
mysql&#62; SELECT 29 MOD 9;
        -&#62; 2
</PRE>

This function is safe to use with <code>BIGINT</code> values.
The <code>N MOD M</code> syntax works only as of MySQL 4.1

<br><br><br><A NAME="IDX1336"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>PI()</code></b></td>
 </tr>
</table>
<br>
<code><b>PI()</b></code><DD></A>
Returns the value of PI. The default number of decimals displayed is five, but
MySQL internally uses the full double precession for PI.


<PRE>
mysql&#62; SELECT PI();
        -&#62; 3.141593
mysql&#62; SELECT PI()+0.000000000000000000;
        -&#62; 3.141592653589793116
</PRE>

<A NAME="IDX1337"></A>
<br><br><br><A NAME="IDX1338"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>POW(X,Y)</code></b></td>
 </tr>
</table>
<br>
<code><b>POW(X,Y)</b></code><DD></A>
<DT><code><b>POWER(X,Y)</b></code><DD>
Returns the value of <code>X</code> raised to the power of <code>Y</code>.


<PRE>
mysql&#62; SELECT POW(2,2);
        -&#62; 4.000000
mysql&#62; SELECT POW(2,-2);
        -&#62; 0.250000
</PRE>

<br><br><br><A NAME="IDX1339"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RADIANS(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>RADIANS(X)</b></code><DD></A>
Returns the argument <code>X</code>, converted from degrees to radians.


<PRE>
mysql&#62; SELECT RADIANS(90);
        -&#62; 1.570796
</PRE>

<br><br><br><A NAME="IDX1340"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RAND()</code></b></td>
 </tr>
</table>
<br>
<code><b>RAND()</b></code><DD></A>
<DT><code><b>RAND(N)</b></code><DD>
Returns a random floating-point value in the range from <code>0</code> to <code>1.0</code>.
If an integer argument <code>N</code> is specified, it is used as the seed value
(producing a repeatable sequence).


<PRE>
mysql&#62; SELECT RAND();
        -&#62; 0.9233482386203
mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047
mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047
mysql&#62; SELECT RAND();
        -&#62; 0.63553050033332
mysql&#62; SELECT RAND();
        -&#62; 0.70100469486881
</PRE>

You can't use a column with <code>RAND()</code> values in an <code>ORDER BY</code>
clause, because <code>ORDER BY</code> would evaluate the column multiple times.
As of MySQL 3.23, you can retrieve rows in random order like this:


<PRE>
mysql&#62; SELECT * FROM tbl_name ORDER BY RAND();
</PRE>

<code>ORDER BY RAND()</code> combined with <code>LIMIT</code> is useful for selecting
a random sample of a set of rows::


<PRE>
mysql&#62; SELECT * FROM table1, table2 WHERE a=b AND c&#60;d
    -&#62; ORDER BY RAND() LIMIT 1000;
</PRE>

Note that <code>RAND()</code> in a <code>WHERE</code> clause is re-evaluated
every time the <code>WHERE</code> is executed.

<code>RAND()</code> is not meant to be a perfect random generator, but instead a
fast way to generate ad hoc random numbers that will be portable between
platforms for the same MySQL version.

<br><br><br><A NAME="IDX1341"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ROUND(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>ROUND(X)</b></code><DD></A>
<DT><code><b>ROUND(X,D)</b></code><DD>
Returns the argument <code>X</code>, rounded to the nearest integer.
With two arguments, returns <code>X</code> rounded to <code>D</code> decimals.


<PRE>
mysql&#62; SELECT ROUND(-1.23);
        -&#62; -1
mysql&#62; SELECT ROUND(-1.58);
        -&#62; -2
mysql&#62; SELECT ROUND(1.58);
        -&#62; 2
mysql&#62; SELECT ROUND(1.298, 1);
        -&#62; 1.3
mysql&#62; SELECT ROUND(1.298, 0);
        -&#62; 1
mysql&#62; SELECT ROUND(23.298, -1);
        -&#62; 20
</PRE>

Note that the behavior of <code>ROUND()</code> when the argument
is halfway between two integers depends on the C library
implementation.  Different implementations round to the nearest even number,
always up, always down, or always toward zero.  If you need
one kind of rounding, you should use a well-defined function
such as <code>TRUNCATE()</code> or <code>FLOOR()</code> instead.

<br><br><br><A NAME="IDX1342"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SIGN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>SIGN(X)</b></code><DD></A>
Returns the sign of the argument as <code>-1</code>, <code>0</code>, or <code>1</code>, depending
on whether <code>X</code> is negative, zero, or positive.


<PRE>
mysql&#62; SELECT SIGN(-32);
        -&#62; -1
mysql&#62; SELECT SIGN(0);
        -&#62; 0
mysql&#62; SELECT SIGN(234);
        -&#62; 1
</PRE>

<br><br><br><A NAME="IDX1343"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SIN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>SIN(X)</b></code><DD></A>
Returns the sine of <code>X</code>, where <code>X</code> is given in radians.


<PRE>
mysql&#62; SELECT SIN(PI());
        -&#62; 0.000000
</PRE>

<br><br><br><A NAME="IDX1344"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SQRT(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>SQRT(X)</b></code><DD></A>
Returns the non-negative square root of <code>X</code>.


<PRE>
mysql&#62; SELECT SQRT(4);
        -&#62; 2.000000
mysql&#62; SELECT SQRT(20);
        -&#62; 4.472136
</PRE>

<br><br><br><A NAME="IDX1345"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TAN(X)</code></b></td>
 </tr>
</table>
<br>
<code><b>TAN(X)</b></code><DD></A>
Returns the tangent of <code>X</code>, where <code>X</code> is given in radians.


<PRE>
mysql&#62; SELECT TAN(PI()+1);
        -&#62; 1.557408
</PRE>

<br><br><br><A NAME="IDX1346"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TRUNCATE(X,D)</code></b></td>
 </tr>
</table>
<br>
<code><b>TRUNCATE(X,D)</b></code><DD></A>
Returns the number <code>X</code>, truncated to <code>D</code> decimals.  If <code>D</code>
is <code>0</code>, the result will have no decimal point or fractional part.


<PRE>
mysql&#62; SELECT TRUNCATE(1.223,1);
        -&#62; 1.2
mysql&#62; SELECT TRUNCATE(1.999,1);
        -&#62; 1.9
mysql&#62; SELECT TRUNCATE(1.999,0);
        -&#62; 1
mysql&#62; SELECT TRUNCATE(-1.999,1);
        -&#62; -1.9
</PRE>

Starting from MySQL 3.23.51, all numbers are rounded toward zero.

If <code>D</code> is negative, the whole part of the number is zeroed out:


<PRE>
mysql&#62; SELECT TRUNCATE(122,-2);
       -&#62; 100
</PRE>

Note that decimal numbers are normally not stored as exact numbers in
computers, but as double-precision values, so you may be surprised by the
following result:

<A NAME="IDX1347"></A>

<PRE>
mysql&#62; SELECT TRUNCATE(10.28*100,0);
       -&#62; 1027
</PRE>

This happens because <code>10.28</code> is actually stored as something like
<code>10.2799999999999999</code>.

</DL>



<H2><A NAME="Date_and_time_functions" HREF="index.html#Date_and_time_functions">13.5  Date and Time Functions</A></H2>

<P>
<A NAME="IDX1348"></A>
<A NAME="IDX1349"></A>

</P>
<P>
This section describes the functions that can be used to manipulate
temporal values.
See section 12.2  Date and Time Types for a description of the range of values
each date and time type has and the valid formats in which values may be
specified.

</P>
<P>
Here is an example that uses date functions.  The following query selects
all records with a <code>date_col</code> value from within the last 30 days:

</P>

<PRE>
mysql&#62; SELECT something FROM tbl_name
    -&#62; WHERE DATE_SUB(CURDATE(),INTERVAL 30 DAY) &#60;= date_col;
</PRE>

<P>
Note that the query also will select records with dates that lie in the
future.

</P>
<P>
Functions that expect date values usually will accept datetime values
and ignore the time part. Functions that expect time values usually will
accept datetime values and ignore the date part.

</P>
<P>
Functions that return the current date or time each are evaluated only once
per query at the start of query execution. This means that multiple references
to a function such as <code>NOW()</code> within a single query will always produce
the same result.  This principle also applies to <code>CURDATE()</code>,
<code>CURTIME()</code>, <code>UTC_DATE()</code>, <code>UTC_TIME()</code>, <code>UTC_TIMESTAMP()</code>,
and any of their synonyms.

</P>
<P>
The return value ranges in the following function descriptions apply for
complete dates. If a date is a ``zero'' value or an incomplete date such
as <code>'2001-11-00'</code>, functions that extract a part of a date may return
<code>0</code>. For example, <code>DAYOFMONTH('2001-11-00')</code> returns <code>0</code>.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1350"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ADDDATE(date,INTERVAL expr type)</code></b></td>
 </tr>
</table>
<br>
<code><b>ADDDATE(date,INTERVAL expr type)</b></code><DD></A>
 
<DT><code><b>ADDDATE(expr,days)</b></code><DD>
When invoked with the <code>INTERVAL</code> form of the second argument,
<code>ADDDATE()</code> is a synonym for <code>DATE_ADD()</code>.  The related
function <code>SUBDATE()</code> is a synonym for <code>DATE_SUB()</code>.


<PRE>
mysql&#62; SELECT DATE_ADD('1998-01-02', INTERVAL 31 DAY);
        -&#62; '1998-02-02'
mysql&#62; SELECT ADDDATE('1998-01-02', INTERVAL 31 DAY);
        -&#62; '1998-02-02'
</PRE>

As of MySQL 4.1.1, the second syntax is allowed, where <code>expr</code> is a date
or datetime expression and <code>days</code> is the number of days to be added to
<code>expr</code>.


<PRE>
mysql&#62; SELECT ADDDATE('1998-01-02', 31);
        -&#62; '1998-02-02'
</PRE>

<br><br><br><A NAME="IDX1351"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ADDTIME(expr,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>ADDTIME(expr,expr2)</b></code><DD></A>
<code>ADDTIME()</code> adds <code>expr2</code> to <code>expr</code> and returns the result.
<code>expr</code> is a date or datetime expression, and <code>expr2</code> is a time
expression.


<PRE>
mysql&#62; SELECT ADDTIME('1997-12-31 23:59:59.999999',
    -&#62;                '1 1:1:1.000002');
        -&#62; '1998-01-02 01:01:01.000001'
mysql&#62; SELECT ADDTIME('01:00:00.999999', '02:00:00.999998');
        -&#62; '03:00:01.999997'
</PRE>

<code>ADDTIME()</code> was added in MySQL 4.1.1.

<br><br><br><A NAME="IDX1352"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURDATE()</code></b></td>
 </tr>
</table>
<br>
<code><b>CURDATE()</b></code><DD></A>
Returns the current date as a value in <code>'YYYY-MM-DD'</code> or <code>YYYYMMDD</code>
format, depending on whether the function is used in a string or numeric
context.


<PRE>
mysql&#62; SELECT CURDATE();
        -&#62; '1997-12-15'
mysql&#62; SELECT CURDATE() + 0;
        -&#62; 19971215
</PRE>

<br><br><br><A NAME="IDX1353"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURRENT_DATE</code></b></td>
 </tr>
</table>
<br>
<code><b>CURRENT_DATE</b></code><DD></A>
<DT><code><b>CURRENT_DATE()</b></code><DD>
<code>CURRENT_DATE</code> and <code>CURRENT_DATE()</code> are synonyms for
<code>CURDATE()</code>.

<br><br><br><A NAME="IDX1354"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURTIME()</code></b></td>
 </tr>
</table>
<br>
<code><b>CURTIME()</b></code><DD></A>
Returns the current time as a value in <code>'HH:MM:SS'</code> or <code>HHMMSS</code>
format, depending on whether the function is used in a string or numeric
context.


<PRE>
mysql&#62; SELECT CURTIME();
        -&#62; '23:50:26'
mysql&#62; SELECT CURTIME() + 0;
        -&#62; 235026
</PRE>

<br><br><br><A NAME="IDX1355"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURRENT_TIME</code></b></td>
 </tr>
</table>
<br>
<code><b>CURRENT_TIME</b></code><DD></A>
<DT><code><b>CURRENT_TIME()</b></code><DD>
<code>CURRENT_TIME</code> and <code>CURRENT_TIME()</code> are synonyms for
<code>CURTIME()</code>.

<br><br><br><A NAME="IDX1356"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURRENT_TIMESTAMP</code></b></td>
 </tr>
</table>
<br>
<code><b>CURRENT_TIMESTAMP</b></code><DD></A>
<DT><code><b>CURRENT_TIMESTAMP()</b></code><DD>
<code>CURRENT_TIMESTAMP</code> and <code>CURRENT_TIMESTAMP()</code> are synonyms for
<code>NOW()</code>.

<br><br><br><A NAME="IDX1357"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DATE(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>DATE(expr)</b></code><DD></A>
Extracts the date part of the date or datetime expression <code>expr</code>.


<PRE>
mysql&#62; SELECT DATE('2003-12-31 01:02:03');
        -&#62; '2003-12-31'
</PRE>

<code>DATE()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1358"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DATEDIFF(expr,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>DATEDIFF(expr,expr2)</b></code><DD></A>
<code>DATEDIFF()</code> returns the number of days between the start date
<code>expr</code> and the end date <code>expr2</code>.
<code>expr</code> and <code>expr2</code> are date or date-and-time expressions.
Only the date parts of the values are used in the calculation.


<PRE>
mysql&#62; SELECT DATEDIFF('1997-12-31 23:59:59','1997-12-30');
        -&#62; 1
mysql&#62; SELECT DATEDIFF('1997-11-30 23:59:59','1997-12-31');
        -&#62; -31
</PRE>

<code>DATEDIFF()</code> was added in MySQL 4.1.1.

<A NAME="IDX1359"></A>
<br><br><br><A NAME="IDX1360"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DATE_ADD(date,INTERVAL expr type)</code></b></td>
 </tr>
</table>
<br>
<code><b>DATE_ADD(date,INTERVAL expr type)</b></code><DD></A>
<DT><code><b>DATE_SUB(date,INTERVAL expr type)</b></code><DD>
These functions perform date arithmetic.
<code>date</code> is a <code>DATETIME</code> or <code>DATE</code> value specifying the starting
date.  <code>expr</code> is an expression specifying the interval value to be added
or subtracted from the starting date.  <code>expr</code> is a string; it may start
with a <samp>`-'</samp> for negative intervals.  <code>type</code> is a keyword indicating
how the expression should be interpreted.

The <code>INTERVAL</code> keyword and the <code>type</code> specifier are not case
sensitive.

The following table shows how the <code>type</code> and <code>expr</code> arguments
are related:

<TABLE BORDER WIDTH="100%">
<TR><TD><code>type</code> <strong>Value</strong> </TD><TD> <strong>Expected</strong> <code>expr</code> <strong>Format</strong>
</TD></TR>
<TR><TD><code>MICROSECOND</code> </TD><TD> <code>MICROSECONDS</code>
</TD></TR>
<TR><TD><code>SECOND</code> </TD><TD> <code>SECONDS</code>
</TD></TR>
<TR><TD><code>MINUTE</code> </TD><TD> <code>MINUTES</code>
</TD></TR>
<TR><TD><code>HOUR</code> </TD><TD> <code>HOURS</code>
</TD></TR>
<TR><TD><code>DAY</code> </TD><TD> <code>DAYS</code>
</TD></TR>
<TR><TD><code>WEEK</code> </TD><TD> <code>WEEKS</code>
</TD></TR>
<TR><TD><code>MONTH</code> </TD><TD> <code>MONTHS</code>
</TD></TR>
<TR><TD><code>QUARTER</code> </TD><TD> <code>QUARTERS</code>
</TD></TR>
<TR><TD><code>YEAR</code> </TD><TD> <code>YEARS</code>
</TD></TR>
<TR><TD><code>SECOND_MICROSECOND</code> </TD><TD> <code>'SECONDS.MICROSECONDS'</code>
</TD></TR>
<TR><TD><code>MINUTE_MICROSECOND</code> </TD><TD> <code>'MINUTES.MICROSECONDS'</code>
</TD></TR>
<TR><TD><code>MINUTE_SECOND</code> </TD><TD> <code>'MINUTES:SECONDS'</code>
</TD></TR>
<TR><TD><code>HOUR_MICROSECOND</code> </TD><TD> <code>'HOURS.MICROSECONDS'</code>
</TD></TR>
<TR><TD><code>HOUR_SECOND</code> </TD><TD> <code>'HOURS:MINUTES:SECONDS'</code>
</TD></TR>
<TR><TD><code>HOUR_MINUTE</code> </TD><TD> <code>'HOURS:MINUTES'</code>
</TD></TR>
<TR><TD><code>DAY_MICROSECOND</code> </TD><TD> <code>'DAYS.MICROSECONDS'</code>
</TD></TR>
<TR><TD><code>DAY_SECOND</code> </TD><TD> <code>'DAYS HOURS:MINUTES:SECONDS'</code>
</TD></TR>
<TR><TD><code>DAY_MINUTE</code> </TD><TD> <code>'DAYS HOURS:MINUTES'</code>
</TD></TR>
<TR><TD><code>DAY_HOUR</code> </TD><TD> <code>'DAYS HOURS'</code>
</TD></TR>
<TR><TD><code>YEAR_MONTH</code> </TD><TD> <code>'YEARS-MONTHS'</code>
</TD></TR>
</TABLE>

The <code>type</code> values <code>DAY_MICROSECOND</code>, <code>HOUR_MICROSECOND</code>,
<code>MINUTE_MICROSECOND</code>, <code>SECOND_MICROSECOND</code>,
and <code>MICROSECOND</code> are allowed as of MySQL 4.1.1.
The values <code>QUARTER</code> and <code>WEEK</code> are allowed as of MySQL 5.0.0.

MySQL allows any punctuation delimiter in the <code>expr</code> format.
Those shown in the table are the suggested delimiters.  If the <code>date</code>
argument is a <code>DATE</code> value and your calculations involve only
<code>YEAR</code>, <code>MONTH</code>, and <code>DAY</code> parts (that is, no time parts), the
result is a <code>DATE</code> value.  Otherwise, the result is a <code>DATETIME</code>
value.

As of MySQL 3.23, <code>INTERVAL expr type</code> is allowed on either
side of the <code>+</code> operator if the expression on the other side is a
date or datetime value.
For the <code>-</code> operator, <code>INTERVAL expr type</code> is allowed only on
the right side, because
it makes no sense to subtract a date or datetime value from an interval.
(See examples below.)


<PRE>
mysql&#62; SELECT '1997-12-31 23:59:59' + INTERVAL 1 SECOND;
        -&#62; '1998-01-01 00:00:00'
mysql&#62; SELECT INTERVAL 1 DAY + '1997-12-31';
        -&#62; '1998-01-01'
mysql&#62; SELECT '1998-01-01' - INTERVAL 1 SECOND;
        -&#62; '1997-12-31 23:59:59'
mysql&#62; SELECT DATE_ADD('1997-12-31 23:59:59',
    -&#62;                 INTERVAL 1 SECOND);
        -&#62; '1998-01-01 00:00:00'
mysql&#62; SELECT DATE_ADD('1997-12-31 23:59:59',
    -&#62;                 INTERVAL 1 DAY);
        -&#62; '1998-01-01 23:59:59'
mysql&#62; SELECT DATE_ADD('1997-12-31 23:59:59',
    -&#62;                 INTERVAL '1:1' MINUTE_SECOND);
        -&#62; '1998-01-01 00:01:00'
mysql&#62; SELECT DATE_SUB('1998-01-01 00:00:00',
    -&#62;                 INTERVAL '1 1:1:1' DAY_SECOND);
        -&#62; '1997-12-30 22:58:59'
mysql&#62; SELECT DATE_ADD('1998-01-01 00:00:00',
    -&#62;                 INTERVAL '-1 10' DAY_HOUR);
        -&#62; '1997-12-30 14:00:00'
mysql&#62; SELECT DATE_SUB('1998-01-02', INTERVAL 31 DAY);
        -&#62; '1997-12-02'
mysql&#62; SELECT DATE_ADD('1992-12-31 23:59:59.000002',
    -&#62;            INTERVAL '1.999999' SECOND_MICROSECOND);
        -&#62; '1993-01-01 00:00:01.000001'
</PRE>

If you specify an interval value that is too short (does not include all the
interval parts that would be expected from the <code>type</code> keyword),
MySQL assumes you have left out the leftmost parts of the interval
value.  For example, if you specify a <code>type</code> of <code>DAY_SECOND</code>, the
value of <code>expr</code> is expected to have days, hours, minutes, and seconds
parts.  If you specify a value like <code>'1:10'</code>, MySQL assumes
that the days and hours parts are missing and the value represents minutes
and seconds.  In other words, <code>'1:10' DAY_SECOND</code> is interpreted in such
a way that it is equivalent to <code>'1:10' MINUTE_SECOND</code>.  This is
analogous to the way that MySQL interprets <code>TIME</code> values
as representing elapsed time rather than as time of day.

If you add to or subtract from a date value something that
contains a time part, the result is automatically converted to a
datetime value:


<PRE>
mysql&#62; SELECT DATE_ADD('1999-01-01', INTERVAL 1 DAY);
        -&#62; '1999-01-02'
mysql&#62; SELECT DATE_ADD('1999-01-01', INTERVAL 1 HOUR);
        -&#62; '1999-01-01 01:00:00'
</PRE>

If you use really malformed dates, the result is <code>NULL</code>. If you add
<code>MONTH</code>, <code>YEAR_MONTH</code>, or <code>YEAR</code> and the resulting date
has a day that is larger than the maximum day for the new month, the day is
adjusted to the maximum days in the new month:


<PRE>
mysql&#62; SELECT DATE_ADD('1998-01-30', INTERVAL 1 MONTH);
        -&#62; '1998-02-28'
</PRE>

<br><br><br><A NAME="IDX1361"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DATE_FORMAT(date,format)</code></b></td>
 </tr>
</table>
<br>
<code><b>DATE_FORMAT(date,format)</b></code><DD></A>
Formats the <code>date</code> value according to the <code>format</code> string. The
following specifiers may be used in the <code>format</code> string:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Specifier</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD><code>%a</code> </TD><TD> Abbreviated weekday name (<code>Sun</code>..<code>Sat</code>)
</TD></TR>
<TR><TD><code>%b</code> </TD><TD> Abbreviated month name (<code>Jan</code>..<code>Dec</code>)
</TD></TR>
<TR><TD><code>%c</code> </TD><TD> Month, numeric (<code>0</code>..<code>12</code>)
</TD></TR>
<TR><TD><code>%D</code> </TD><TD> Day of the month with English suffix (<code>0th</code>, <code>1st</code>, <code>2nd</code>, <code>3rd</code>, ...)
</TD></TR>
<TR><TD><code>%d</code> </TD><TD> Day of the month, numeric (<code>00</code>..<code>31</code>)
</TD></TR>
<TR><TD><code>%e</code> </TD><TD> Day of the month, numeric (<code>0</code>..<code>31</code>)
</TD></TR>
<TR><TD><code>%f</code> </TD><TD> Microseconds (<code>000000</code>..<code>999999</code>)
</TD></TR>
<TR><TD><code>%H</code> </TD><TD> Hour (<code>00</code>..<code>23</code>)
</TD></TR>
<TR><TD><code>%h</code> </TD><TD> Hour (<code>01</code>..<code>12</code>)
</TD></TR>
<TR><TD><code>%I</code> </TD><TD> Hour (<code>01</code>..<code>12</code>)
</TD></TR>
<TR><TD><code>%i</code> </TD><TD> Minutes, numeric (<code>00</code>..<code>59</code>)
</TD></TR>
<TR><TD><code>%j</code> </TD><TD> Day of year (<code>001</code>..<code>366</code>)
</TD></TR>
<TR><TD><code>%k</code> </TD><TD> Hour (<code>0</code>..<code>23</code>)
</TD></TR>
<TR><TD><code>%l</code> </TD><TD> Hour (<code>1</code>..<code>12</code>)
</TD></TR>
<TR><TD><code>%M</code> </TD><TD> Month name (<code>January</code>..<code>December</code>)
</TD></TR>
<TR><TD><code>%m</code> </TD><TD> Month, numeric (<code>00</code>..<code>12</code>)
</TD></TR>
<TR><TD><code>%p</code> </TD><TD> <code>AM</code> or <code>PM</code>
</TD></TR>
<TR><TD><code>%r</code> </TD><TD> Time, 12-hour (<code>hh:mm:ss</code> followed by <code>AM</code> or <code>PM</code>)
</TD></TR>
<TR><TD><code>%S</code> </TD><TD> Seconds (<code>00</code>..<code>59</code>)
</TD></TR>
<TR><TD><code>%s</code> </TD><TD> Seconds (<code>00</code>..<code>59</code>)
</TD></TR>
<TR><TD><code>%T</code> </TD><TD> Time, 24-hour (<code>hh:mm:ss</code>)
</TD></TR>
<TR><TD><code>%U</code> </TD><TD> Week (<code>00</code>..<code>53</code>), where Sunday is the first day of the week
</TD></TR>
<TR><TD><code>%u</code> </TD><TD> Week (<code>00</code>..<code>53</code>), where Monday is the first day of the week
</TD></TR>
<TR><TD><code>%V</code> </TD><TD> Week (<code>01</code>..<code>53</code>), where Sunday is the first day of the week; used with <code>%X</code>
</TD></TR>
<TR><TD><code>%v</code> </TD><TD> Week (<code>01</code>..<code>53</code>), where Monday is the first day of the week; used with <code>%x</code>
</TD></TR>
<TR><TD><code>%W</code> </TD><TD> Weekday name (<code>Sunday</code>..<code>Saturday</code>)
</TD></TR>
<TR><TD><code>%w</code> </TD><TD> Day of the week (<code>0</code>=Sunday..<code>6</code>=Saturday)
</TD></TR>
<TR><TD><code>%X</code> </TD><TD> Year for the week where Sunday is the first day of the week, numeric, 4 digits; used with <code>%V</code>
</TD></TR>
<TR><TD><code>%x</code> </TD><TD> Year for the week, where Monday is the first day of the week, numeric, 4 digits; used with <code>%v</code>
</TD></TR>
<TR><TD><code>%Y</code> </TD><TD> Year, numeric, 4 digits
</TD></TR>
<TR><TD><code>%y</code> </TD><TD> Year, numeric, 2 digits
</TD></TR>
<TR><TD><code>%%</code> </TD><TD> A literal <samp>`%'</samp>.
</TD></TR>
</TABLE>

All other characters are copied to the result without interpretation.

The <code>%v</code>, <code>%V</code>, <code>%x</code>, and <code>%X</code> format specifiers are
available as of MySQL 3.23.8.  <code>%f</code> is available as of MySQL 4.1.1.

As of MySQL 3.23, the <samp>`%'</samp> character is required before
format specifier characters.  In earlier versions of MySQL,
<samp>`%'</samp> was optional.

The reason the ranges for the month and day specifiers begin with zero
is that MySQL allows incomplete dates such as <code>'2004-00-00'</code> to be
stored as of MySQL 3.23.


<PRE>
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&#62; 'Saturday October 1997'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&#62; '22:23:00'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00',
                          '%D %y %a %d %m %b %j');
        -&#62; '4th 97 Sat 04 10 Oct 277'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00',
                          '%H %k %I %r %T %S %w');
        -&#62; '22 22 10 10:23:00 PM 22:23:00 00 6'
mysql&#62; SELECT DATE_FORMAT('1999-01-01', '%X %V');
        -&#62; '1998 52'
</PRE>

<br><br><br><A NAME="IDX1362"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DAY(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>DAY(date)</b></code><DD></A>
<code>DAY()</code> is a synonym for <code>DAYOFMONTH()</code>.
It is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1363"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DAYNAME(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>DAYNAME(date)</b></code><DD></A>
Returns the name of the weekday for <code>date</code>.


<PRE>
mysql&#62; SELECT DAYNAME('1998-02-05');
        -&#62; 'Thursday'
</PRE>

<br><br><br><A NAME="IDX1364"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DAYOFMONTH(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>DAYOFMONTH(date)</b></code><DD></A>
Returns the day of the month for <code>date</code>, in the range <code>1</code> to
<code>31</code>.


<PRE>
mysql&#62; SELECT DAYOFMONTH('1998-02-03');
        -&#62; 3
</PRE>

<br><br><br><A NAME="IDX1365"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DAYOFWEEK(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>DAYOFWEEK(date)</b></code><DD></A>
Returns the weekday index
for <code>date</code> (<code>1</code> = Sunday, <code>2</code> = Monday, ... <code>7</code> =
Saturday).  These index values correspond to the ODBC standard.


<PRE>
mysql&#62; SELECT DAYOFWEEK('1998-02-03');
        -&#62; 3
</PRE>

<br><br><br><A NAME="IDX1366"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DAYOFYEAR(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>DAYOFYEAR(date)</b></code><DD></A>
Returns the day of the year for <code>date</code>, in the range <code>1</code> to
<code>366</code>.


<PRE>
mysql&#62; SELECT DAYOFYEAR('1998-02-03');
        -&#62; 34
</PRE>

<br><br><br><A NAME="IDX1367"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>EXTRACT(type FROM date)</code></b></td>
 </tr>
</table>
<br>
<code><b>EXTRACT(type FROM date)</b></code><DD></A>
The <code>EXTRACT()</code> function uses the same kinds of interval type
specifiers as <code>DATE_ADD()</code> or <code>DATE_SUB()</code>, but extracts parts
from the date rather than performing date arithmetic.


<PRE>
mysql&#62; SELECT EXTRACT(YEAR FROM '1999-07-02');
       -&#62; 1999
mysql&#62; SELECT EXTRACT(YEAR_MONTH FROM '1999-07-02 01:02:03');
       -&#62; 199907
mysql&#62; SELECT EXTRACT(DAY_MINUTE FROM '1999-07-02 01:02:03');
       -&#62; 20102
mysql&#62; SELECT EXTRACT(MICROSECOND
    -&#62;                FROM '2003-01-02 10:30:00.00123');
        -&#62; 123
</PRE>

<br><br><br><A NAME="IDX1368"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FROM_DAYS(N)</code></b></td>
 </tr>
</table>
<br>
<code><b>FROM_DAYS(N)</b></code><DD></A>
Given a daynumber <code>N</code>, returns a <code>DATE</code> value.


<PRE>
mysql&#62; SELECT FROM_DAYS(729669);
        -&#62; '1997-10-07'
</PRE>

<code>FROM_DAYS()</code> is not intended for use with values that precede the
advent of the Gregorian calendar (1582), because it doesn't take into account
the days that were lost when the calendar was changed.

<br><br><br><A NAME="IDX1369"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FROM_UNIXTIME(unix_timestamp)</code></b></td>
 </tr>
</table>
<br>
<code><b>FROM_UNIXTIME(unix_timestamp)</b></code><DD></A>
<DT><code><b>FROM_UNIXTIME(unix_timestamp,format)</b></code><DD>
Returns a representation of the <code>unix_timestamp</code> argument as a value in
<code>'YYYY-MM-DD HH:MM:SS'</code> or <code>YYYYMMDDHHMMSS</code> format, depending on
whether the function is used in a string or numeric context.


<PRE>
mysql&#62; SELECT FROM_UNIXTIME(875996580);
        -&#62; '1997-10-04 22:23:00'
mysql&#62; SELECT FROM_UNIXTIME(875996580) + 0;
        -&#62; 19971004222300
</PRE>

If <code>format</code> is given, the result is formatted according to the
<code>format</code> string. <code>format</code> may contain the same specifiers as
those listed in the entry for the <code>DATE_FORMAT()</code> function.


<PRE>
mysql&#62; SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(),
    -&#62;                      '%Y %D %M %h:%i:%s %x');
        -&#62; '2003 6th August 06:22:58 2003'
</PRE>

<br><br><br><A NAME="IDX1370"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>GET_FORMAT(DATE | TIME | TIMESTAMP, 'EUR' | 'USA' | 'JIS' | 'ISO' | 'INTERNAL')</code></b></td>
 </tr>
</table>
<br>
<code><b>GET_FORMAT(DATE | TIME | TIMESTAMP, 'EUR' | 'USA' | 'JIS' | 'ISO' | 'INTERNAL')</b></code><DD></A>
Returns a format string. This function is useful in combination with the 
<code>DATE_FORMAT()</code> and the <code>STR_TO_DATE()</code> functions.
The three possible values for the first argument 
and the five possible values for the second argument result in 15 possible 
format strings (for the specifiers used, see the table in the 
<code>DATE_FORMAT()</code> function description).
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Function Call</strong> </TD><TD> <strong>Result</strong>
</TD></TR>
<TR><TD><code>GET_FORMAT(DATE,'USA')</code> </TD><TD> <code>'%m.%d.%Y'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(DATE,'JIS')</code> </TD><TD> <code>'%Y-%m-%d'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(DATE,'ISO')</code> </TD><TD> <code>'%Y-%m-%d'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(DATE,'EUR')</code> </TD><TD> <code>'%d.%m.%Y'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(DATE,'INTERNAL')</code> </TD><TD> <code>'%Y%m%d'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIMESTAMP,'USA')</code> </TD><TD> <code>'%Y-%m-%d-%H.%i.%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIMESTAMP,'JIS')</code> </TD><TD> <code>'%Y-%m-%d %H:%i:%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIMESTAMP,'ISO')</code> </TD><TD> <code>'%Y-%m-%d %H:%i:%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIMESTAMP,'EUR')</code> </TD><TD> <code>'%Y-%m-%d-%H.%i.%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIMESTAMP,'INTERNAL')</code> </TD><TD> <code>'%Y%m%d%H%i%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIME,'USA')</code> </TD><TD> <code>'%h:%i:%s %p'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIME,'JIS')</code> </TD><TD> <code>'%H:%i:%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIME,'ISO')</code> </TD><TD> <code>'%H:%i:%s'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIME,'EUR')</code> </TD><TD> <code>'%H.%i.%S'</code>
</TD></TR>
<TR><TD><code>GET_FORMAT(TIME,'INTERNAL')</code> </TD><TD> <code>'%H%i%s'</code>
</TD></TR>
</TABLE>
ISO format is ISO 9075, not ISO 8601.


<PRE>
mysql&#62; SELECT DATE_FORMAT('2003-10-03',
    -&#62;                    GET_FORMAT(DATE, 'EUR')
        -&#62; '03.10.2003'
mysql&#62; SELECT STR_TO_DATE('10.31.2003',
    -&#62;                    GET_FORMAT(DATE, 'USA'))
        -&#62; 2003-10-31
</PRE>

<code>GET_FORMAT()</code> is available as of MySQL 4.1.1.
See See section <A HREF="manual_SQL_Syntax.html#SET_OPTION">14.5.3.1  <code>SET</code> Syntax</A>.

<br><br><br><A NAME="IDX1371"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>HOUR(time)</code></b></td>
 </tr>
</table>
<br>
<code><b>HOUR(time)</b></code><DD></A>
Returns the hour for <code>time</code>. The range of the return value will be
<code>0</code> to <code>23</code> for time-of-day values.


<PRE>
mysql&#62; SELECT HOUR('10:05:03');
        -&#62; 10
</PRE>

However, the range of <code>TIME</code> values actually is much larger, so
<code>HOUR</code> can return values greater than <code>23</code>.

<PRE>

mysql&#62; SELECT HOUR('272:59:59');
        -&#62; 272
</PRE>

<br><br><br><A NAME="IDX1372"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LAST_DAY(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>LAST_DAY(date)</b></code><DD></A>
Takes a date or datetime value and returns the corresponding value for the
last day of the month.  Returns <code>NULL</code> if the argument is invalid.


<PRE>
mysql&#62; SELECT LAST_DAY('2003-02-05');
        -&#62; '2003-02-28'
mysql&#62; SELECT LAST_DAY('2004-02-05');
        -&#62; '2004-02-29'
mysql&#62; SELECT LAST_DAY('2004-01-01 01:01:01');
        -&#62; '2004-01-31'
mysql&#62; SELECT LAST_DAY('2003-03-32');
        -&#62; NULL
</PRE>

<code>LAST_DAY()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1373"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOCALTIME</code></b></td>
 </tr>
</table>
<br>
<code><b>LOCALTIME</b></code><DD></A>
<DT><code><b>LOCALTIME()</b></code><DD>
<code>LOCALTIME</code> and <code>LOCALTIME()</code> are synonyms for
<code>NOW()</code>.

<br><br><br><A NAME="IDX1374"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LOCALTIMESTAMP</code></b></td>
 </tr>
</table>
<br>
<code><b>LOCALTIMESTAMP</b></code><DD></A>
<DT><code><b>LOCALTIMESTAMP()</b></code><DD>
<code>LOCALTIMESTAMP</code> and <code>LOCALTIMESTAMP()</code> are synonyms for
<code>NOW()</code>.

<br><br><br><A NAME="IDX1375"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MAKEDATE(year,dayofyear)</code></b></td>
 </tr>
</table>
<br>
<code><b>MAKEDATE(year,dayofyear)</b></code><DD></A>
Returns a date, given year and day-of-year values.
<code>dayofyear</code> must be greater than 0 or the result will <code>NULL</code>.


<PRE>
mysql&#62; SELECT MAKEDATE(2001,31), MAKEDATE(2001,32);
        -&#62; '2001-01-31', '2001-02-01'
mysql&#62; SELECT MAKEDATE(2001,365), MAKEDATE(2004,365);
        -&#62; '2001-12-31', '2004-12-30'
mysql&#62; SELECT MAKEDATE(2001,0);
        -&#62; NULL
</PRE>

<code>MAKEDATE()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1376"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MAKETIME(hour,minute,second)</code></b></td>
 </tr>
</table>
<br>
<code><b>MAKETIME(hour,minute,second)</b></code><DD></A>
Returns a time value calculated from the <code>hour</code>, <code>minute</code>, and
<code>second</code> arguments.


<PRE>
mysql&#62; SELECT MAKETIME(12,15,30);
        -&#62; '12:15:30'
</PRE>

<code>MAKETIME()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1377"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MICROSECOND(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>MICROSECOND(expr)</b></code><DD></A>
Returns the microseconds from the time or datetime expression <code>expr</code> as a
number in the range from <code>0</code> to <code>999999</code>.


<PRE>
mysql&#62; SELECT MICROSECOND('12:00:00.123456');
        -&#62; 123456
mysql&#62; SELECT MICROSECOND('1997-12-31 23:59:59.000010');
        -&#62; 10
</PRE>

<code>MICROSECOND()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1378"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MINUTE(time)</code></b></td>
 </tr>
</table>
<br>
<code><b>MINUTE(time)</b></code><DD></A>
Returns the minute for <code>time</code>, in the range <code>0</code> to <code>59</code>.


<PRE>
mysql&#62; SELECT MINUTE('98-02-03 10:05:03');
        -&#62; 5
</PRE>

<br><br><br><A NAME="IDX1379"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MONTH(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>MONTH(date)</b></code><DD></A>
Returns the month for <code>date</code>, in the range <code>1</code> to <code>12</code>.


<PRE>
mysql&#62; SELECT MONTH('1998-02-03');
        -&#62; 2
</PRE>

<br><br><br><A NAME="IDX1380"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MONTHNAME(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>MONTHNAME(date)</b></code><DD></A>
Returns the full name of the month for <code>date</code>.


<PRE>
mysql&#62; SELECT MONTHNAME('1998-02-05');
        -&#62; 'February'
</PRE>

<br><br><br><A NAME="IDX1381"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>NOW()</code></b></td>
 </tr>
</table>
<br>
<code><b>NOW()</b></code><DD></A>
Returns the current date and time as a value in <code>'YYYY-MM-DD HH:MM:SS'</code>
or <code>YYYYMMDDHHMMSS</code> format, depending on whether the function is used in
a string or numeric context.


<PRE>
mysql&#62; SELECT NOW();
        -&#62; '1997-12-15 23:50:26'
mysql&#62; SELECT NOW() + 0;
        -&#62; 19971215235026
</PRE>

<br><br><br><A NAME="IDX1382"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>PERIOD_ADD(P,N)</code></b></td>
 </tr>
</table>
<br>
<code><b>PERIOD_ADD(P,N)</b></code><DD></A>
Adds <code>N</code> months to period <code>P</code> (in the format <code>YYMM</code> or
<code>YYYYMM</code>). Returns a value in the format <code>YYYYMM</code>.
Note that the period argument <code>P</code> is <em>not</em> a date value.


<PRE>
mysql&#62; SELECT PERIOD_ADD(9801,2);
        -&#62; 199803
</PRE>

<br><br><br><A NAME="IDX1383"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>PERIOD_DIFF(P1,P2)</code></b></td>
 </tr>
</table>
<br>
<code><b>PERIOD_DIFF(P1,P2)</b></code><DD></A>
Returns the number of months between periods <code>P1</code> and <code>P2</code>.
<code>P1</code> and <code>P2</code> should be in the format <code>YYMM</code> or <code>YYYYMM</code>.
Note that the period arguments <code>P1</code> and <code>P2</code> are <em>not</em>
date values.


<PRE>
mysql&#62; SELECT PERIOD_DIFF(9802,199703);
        -&#62; 11
</PRE>

<br><br><br><A NAME="IDX1384"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>QUARTER(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>QUARTER(date)</b></code><DD></A>
Returns the quarter of the year for <code>date</code>, in the range <code>1</code>
to <code>4</code>.


<PRE>
mysql&#62; SELECT QUARTER('98-04-01');
        -&#62; 2
</PRE>

<br><br><br><A NAME="IDX1385"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SECOND(time)</code></b></td>
 </tr>
</table>
<br>
<code><b>SECOND(time)</b></code><DD></A>
Returns the second for <code>time</code>, in the range <code>0</code> to <code>59</code>.


<PRE>
mysql&#62; SELECT SECOND('10:05:03');
        -&#62; 3
</PRE>

<br><br><br><A NAME="IDX1386"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SEC_TO_TIME(seconds)</code></b></td>
 </tr>
</table>
<br>
<code><b>SEC_TO_TIME(seconds)</b></code><DD></A>
Returns the <code>seconds</code> argument, converted to hours, minutes, and seconds,
as a value in <code>'HH:MM:SS'</code> or <code>HHMMSS</code> format, depending on whether
the function is used in a string or numeric context.


<PRE>
mysql&#62; SELECT SEC_TO_TIME(2378);
        -&#62; '00:39:38'
mysql&#62; SELECT SEC_TO_TIME(2378) + 0;
        -&#62; 3938
</PRE>

<br><br><br><A NAME="IDX1387"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>STR_TO_DATE(str,format)</code></b></td>
 </tr>
</table>
<br>
<code><b>STR_TO_DATE(str,format)</b></code><DD></A>
This is the reverse function of the <code>DATE_FORMAT()</code> function. It takes a 
string <code>str</code>, and a format string <code>format</code>, and returns a 
<code>DATETIME</code> value.
The date, time, or datetime values contained in <code>str</code> should be given 
in the format indicated by <code>format</code>. For the specifiers that can be 
used in <code>format</code>, see the table in the <code>DATE_FORMAT()</code> function 
description. All other characters are just taken verbatim, thus not being 
interpreted.
If <code>str</code> contains an illegal date, time, or datetime value, 
<code>STR_TO_DATE()</code> returns <code>NULL</code>.


<PRE>
mysql&#62; SELECT STR_TO_DATE('03.10.2003 09.20',
    -&#62;                    '%d.%m.%Y %H.%i');
        -&#62; '2003-10-03 09:20:00'
mysql&#62; SELECT STR_TO_DATE('10arp', '%carp');
        -&#62; '0000-10-00 00:00:00'
mysql&#62; SELECT STR_TO_DATE('2003-15-10 00:00:00',
    -&#62;                    '%Y-%m-%d %H:%i:%s');
        -&#62; NULL
</PRE>

<code>STR_TO_DATE()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1388"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SUBDATE(date,INTERVAL expr type)</code></b></td>
 </tr>
</table>
<br>
<code><b>SUBDATE(date,INTERVAL expr type)</b></code><DD></A>
<DT><code><b>SUBDATE(expr,days)</b></code><DD>
When invoked with the <code>INTERVAL</code> form of the second argument,
<code>SUBDATE()</code> is a synonym for <code>DATE_SUB()</code>.


<PRE>
mysql&#62; SELECT DATE_SUB('1998-01-02', INTERVAL 31 DAY);
        -&#62; '1997-12-02'
mysql&#62; SELECT SUBDATE('1998-01-02', INTERVAL 31 DAY);
        -&#62; '1997-12-02'
</PRE>

As of MySQL 4.1.1, the second syntax is allowed, where <code>expr</code> is a date
or datetime expression and <code>days</code> is the number of days to be
subtracted from <code>expr</code>.


<PRE>
mysql&#62; SELECT SUBDATE('1998-01-02 12:00:00', 31);
        -&#62; '1997-12-02 12:00:00'
</PRE>

<br><br><br><A NAME="IDX1389"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SUBTIME(expr,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>SUBTIME(expr,expr2)</b></code><DD></A>
<code>SUBTIME()</code> subtracts <code>expr2</code> from <code>expr</code> and returns the result.
<code>expr</code> is a date or datetime expression, and <code>expr2</code> is a time
expression.


<PRE>
mysql&#62; SELECT SUBTIME('1997-12-31 23:59:59.999999',
    -&#62;                '1 1:1:1.000002');
        -&#62; '1997-12-30 22:58:58.999997'
mysql&#62; SELECT SUBTIME('01:00:00.999999', '02:00:00.999998');
        -&#62; '-00:59:59.999999'
</PRE>

<code>SUBTIME()</code> was added in MySQL 4.1.1.

<br><br><br><A NAME="IDX1390"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SYSDATE()</code></b></td>
 </tr>
</table>
<br>
<code><b>SYSDATE()</b></code><DD></A>
<code>SYSDATE()</code> is a synonym for <code>NOW()</code>.

<br><br><br><A NAME="IDX1391"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIME(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIME(expr)</b></code><DD></A>
Extracts the time part of the time or datetime expression <code>expr</code>.


<PRE>
mysql&#62; SELECT TIME('2003-12-31 01:02:03');
        -&#62; '01:02:03'
mysql&#62; SELECT TIME('2003-12-31 01:02:03.000123');
        -&#62; '01:02:03.000123'
</PRE>

<code>TIME()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1392"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIMEDIFF(expr,expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIMEDIFF(expr,expr2)</b></code><DD></A>
<code>TIMEDIFF()</code> returns the time between the start time
<code>expr</code> and the end time <code>expr2</code>.
<code>expr</code> and <code>expr2</code> are time or date-and-time expressions, but both
must be of the same type.


<PRE>
mysql&#62; SELECT TIMEDIFF('2000:01:01 00:00:00',
    -&#62;                 '2000:01:01 00:00:00.000001');
        -&#62; '-00:00:00.000001'
mysql&#62; SELECT TIMEDIFF('1997-12-31 23:59:59.000001',
    -&#62;                 '1997-12-30 01:01:01.000002');
        -&#62; '46:58:57.999999'
</PRE>

<code>TIMEDIFF()</code> was added in MySQL 4.1.1.

<br><br><br><A NAME="IDX1393"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIMESTAMP(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIMESTAMP(expr)</b></code><DD></A>
<DT><code><b>TIMESTAMP(expr,expr2)</b></code><DD>
With one argument, returns the date or datetime expression <code>expr</code>
as a datetime value.
With two arguments, adds the time expression <code>expr2</code> to the
date or datetime expression <code>expr</code> and returns a datetime value.


<PRE>
mysql&#62; SELECT TIMESTAMP('2003-12-31');
        -&#62; '2003-12-31 00:00:00'
mysql&#62; SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00');
        -&#62; '2004-01-01 00:00:00'
</PRE>

<code>TIMESTAMP()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1394"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIMESTAMPADD(interval,int_expr,datetime_expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIMESTAMPADD(interval,int_expr,datetime_expr)</b></code><DD></A>
Adds the integer expression <code>int_expr</code> to the date or datetime expression
<code>datetime_expr</code>. The unit for <code>int_expr</code> is given by the
<code>interval</code> argument, which should be one of the following values:
<code>FRAC_SECOND</code>,
<code>SECOND</code>,
<code>MINUTE</code>,
<code>HOUR</code>,
<code>DAY</code>,
<code>WEEK</code>,
<code>MONTH</code>,
<code>QUARTER</code>,
or
<code>YEAR</code>.

The <code>interval</code> value may be specified using one of keywords as shown,
or with a prefix of <code>SQL_TSI_</code>. For example, <code>DAY</code> or
<code>SQL_TSI_DAY</code> both are legal.


<PRE>
mysql&#62; SELECT TIMESTAMPADD(MINUTE,1,'2003-01-02');
        -&#62; '2003-01-02 00:01:00'
mysql&#62; SELECT TIMESTAMPADD(WEEK,1,'2003-01-02');
        -&#62; '2003-01-09'
</PRE>

<code>TIMESTAMPADD()</code> is available as of MySQL 5.0.0.

<br><br><br><A NAME="IDX1395"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)</b></code><DD></A>
Returns the integer difference between the date or datetime expressions
<code>datetime_expr1</code> and
<code>datetime_expr2</code>. The unit for the result is given by the
<code>interval</code> argument. The legal values for <code>interval</code> are the same as
those described in the desription of the <code>TIMESTAMPADD()</code> function.


<PRE>
mysql&#62; SELECT TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01');
        -&#62; 3
mysql&#62; SELECT TIMESTAMPDIFF(YEAR,'2002-05-01','2001-01-01');
        -&#62; -1
</PRE>

<code>TIMESTAMPDIFF()</code> is available as of MySQL 5.0.0.

<br><br><br><A NAME="IDX1396"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIME_FORMAT(time,format)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIME_FORMAT(time,format)</b></code><DD></A>
This is used like the <code>DATE_FORMAT()</code> function, but the
<code>format</code> string may contain only those format specifiers that handle
hours, minutes, and seconds.  Other specifiers produce a <code>NULL</code> value or
<code>0</code>.

If the <code>time</code> value contains an hour part that is greater than
<code>23</code>, the <code>%H</code> and <code>%k</code> hour format specifiers produce a
value larger than the usual range of <code>0..23</code>. The other hour format
specifiers produce the hour value modulo 12.


<PRE>
mysql&#62; SELECT TIME_FORMAT('100:00:00', '%H %k %h %I %l');
        -&#62; '100 100 04 04 4'
</PRE>

<br><br><br><A NAME="IDX1397"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TIME_TO_SEC(time)</code></b></td>
 </tr>
</table>
<br>
<code><b>TIME_TO_SEC(time)</b></code><DD></A>
Returns the <code>time</code> argument, converted to seconds.


<PRE>
mysql&#62; SELECT TIME_TO_SEC('22:23:00');
        -&#62; 80580
mysql&#62; SELECT TIME_TO_SEC('00:39:38');
        -&#62; 2378
</PRE>

<br><br><br><A NAME="IDX1398"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>TO_DAYS(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>TO_DAYS(date)</b></code><DD></A>
Given a date <code>date</code>, returns a daynumber (the number of days since year
0).


<PRE>
mysql&#62; SELECT TO_DAYS(950501);
        -&#62; 728779
mysql&#62; SELECT TO_DAYS('1997-10-07');
        -&#62; 729669
</PRE>

<code>TO_DAYS()</code> is not intended for use with values that precede the advent
of the Gregorian calendar (1582), because it doesn't take into account the
days that were lost when the calendar was changed.

Take into account that MySQL converts two-digit year values in dates to
four-digit form using the rules in section 12.2  Date and Time Types.  For example,
<code>'1997-10-07'</code> and <code>'97-10-07'</code> are seen as identical dates:


<PRE>
mysql&#62; SELECT TO_DAYS('1997-10-07'), TO_DAYS('97-10-07');
        -&#62; 729669, 729669
</PRE>

For other dates before 1582, results from this function are undefined.

<br><br><br><A NAME="IDX1399"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UNIX_TIMESTAMP()</code></b></td>
 </tr>
</table>
<br>
<code><b>UNIX_TIMESTAMP()</b></code><DD></A>
<DT><code><b>UNIX_TIMESTAMP(date)</b></code><DD>
If called with no argument, returns a Unix timestamp (seconds since
<code>'1970-01-01 00:00:00'</code> GMT) as an unsigned integer. If
<code>UNIX_TIMESTAMP()</code> is called with a <code>date</code> argument, it
returns the value of the argument as seconds since <code>'1970-01-01
00:00:00'</code> GMT.  <code>date</code> may be a <code>DATE</code> string, a
<code>DATETIME</code> string, a <code>TIMESTAMP</code>, or a number in the format
<code>YYMMDD</code> or <code>YYYYMMDD</code> in local time.


<PRE>
mysql&#62; SELECT UNIX_TIMESTAMP();
        -&#62; 882226357
mysql&#62; SELECT UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&#62; 875996580
</PRE>

When <code>UNIX_TIMESTAMP</code> is used on a <code>TIMESTAMP</code> column, the function
returns the internal timestamp value directly, with no implicit
``string-to-Unix-timestamp'' conversion.
If you pass an out-of-range date to <code>UNIX_TIMESTAMP()</code>, it
returns <code>0</code>, but please note that only basic range checking is performed
(year from <code>1970</code> to <code>2037</code>, month from <code>01</code> to <code>12</code>, day
from <code>01</code> from <code>31</code>).

If you want to subtract <code>UNIX_TIMESTAMP()</code> columns, you might want to
cast the result to signed integers. See section 13.7  Cast Functions.

<br><br><br><A NAME="IDX1400"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UTC_DATE</code></b></td>
 </tr>
</table>
<br>
<code><b>UTC_DATE</b></code><DD></A>
<DT><code><b>UTC_DATE()</b></code><DD>
Returns the current UTC date as a value in <code>'YYYY-MM-DD'</code> or
<code>YYYYMMDD</code> format, depending on whether the function is used in a
string or numeric context.


<PRE>
mysql&#62; SELECT UTC_DATE(), UTC_DATE() + 0;
        -&#62; '2003-08-14', 20030814
</PRE>

<code>UTC_DATE()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1401"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UTC_TIME</code></b></td>
 </tr>
</table>
<br>
<code><b>UTC_TIME</b></code><DD></A>
<DT><code><b>UTC_TIME()</b></code><DD>
Returns the current UTC time as a value in <code>'HH:MM:SS'</code> or <code>HHMMSS</code>
format, depending on whether the function is used in a string or numeric
context.


<PRE>
mysql&#62; SELECT UTC_TIME(), UTC_TIME() + 0;
        -&#62; '18:07:53', 180753
</PRE>

<code>UTC_TIME()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1402"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UTC_TIMESTAMP</code></b></td>
 </tr>
</table>
<br>
<code><b>UTC_TIMESTAMP</b></code><DD></A>
<DT><code><b>UTC_TIMESTAMP()</b></code><DD>
Returns the current UTC date and time as a value in <code>'YYYY-MM-DD HH:MM:SS'</code>
or <code>YYYYMMDDHHMMSS</code> format, depending on whether the function is used in
a string or numeric context.


<PRE>
mysql&#62; SELECT UTC_TIMESTAMP(), UTC_TIMESTAMP() + 0;
        -&#62; '2003-08-14 18:08:04', 20030814180804
</PRE>

<code>UTC_TIMESTAMP()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1403"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>WEEK(date [,mode])</code></b></td>
 </tr>
</table>
<br>
<code><b>WEEK(date [,mode])</b></code><DD></A>
The function returns the week number for <code>date</code>.  The two-argument form
of <code>WEEK()</code> allows you to specify whether the week starts on Sunday or
Monday and whether the return value should be in the range from <code>0</code> to
<code>53</code> or from <code>1</code> to <code>52</code>. When the <code>mode</code> argument is
omitted, the value of the <code>default_week_format</code> server variable is
assumed (or <code>0</code> before MySQL 4.0.14).
See section 5.2.3  Server System Variables.

The following table demonstrates how the <code>mode</code> argument works:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Value</strong> </TD><TD> <strong>Meaning</strong>
</TD></TR>
<TR><TD><code>0</code> </TD><TD> Week starts on Sunday; return value range is <code>0</code> to
<code>53</code>; week 1 is the first week that starts in this year
</TD></TR>
<TR><TD><code>1</code> </TD><TD> Week starts on Monday; return value range is <code>0</code> to
<code>53</code>; week 1 is the first week that has more than 3 days in this year
</TD></TR>
<TR><TD><code>2</code> </TD><TD> Week starts on Sunday; return value range is <code>1</code> to
<code>53</code>; week 1 is the first week that starts in this year
</TD></TR>
<TR><TD><code>3</code> </TD><TD> Week starts on Monday; return value range is <code>1</code> to
<code>53</code>; week 1 is the first week that has more than 3 days in this year
</TD></TR>
<TR><TD><code>4</code> </TD><TD> Week starts on Sunday; return value range is <code>0</code> to
<code>53</code>; week 1 is the first week that has more than 3 days in this year
</TD></TR>
<TR><TD><code>5</code> </TD><TD> Week starts on Monday; return value range is <code>0</code> to
<code>53</code>; week 1 is the first week that starts in this year
</TD></TR>
<TR><TD><code>6</code> </TD><TD> Week starts on Sunday; return value range is <code>1</code> to
<code>53</code>; week 1 is the first week that has more than 3 days in this year
</TD></TR>
<TR><TD><code>7</code> </TD><TD> Week starts on Monday; return value range is <code>1</code> to
<code>53</code>; week 1 is the first week that starts in this year
</TD></TR>
</TABLE>

The <code>mode</code> value of <code>3</code> can be used as of MySQL 4.0.5.
The <code>mode</code> values of <code>4</code> and above can be used as of MySQL 4.0.17.


<PRE>
mysql&#62; SELECT WEEK('1998-02-20');
        -&#62; 7
mysql&#62; SELECT WEEK('1998-02-20',0);
        -&#62; 7
mysql&#62; SELECT WEEK('1998-02-20',1);
        -&#62; 8
mysql&#62; SELECT WEEK('1998-12-31',1);
        -&#62; 53
</PRE>

Note: In MySQL 4.0, <code>WEEK(date,0)</code> was changed to match the
calendar in the USA.  Before that, <code>WEEK()</code> was calculated incorrectly
for dates in USA. (In effect, <code>WEEK(date)</code> and <code>WEEK(date,0)</code> were
incorrect for all cases.)

Note that if a date falls in the last week of the previous year, MySQL
returns <code>0</code> if you don't use <code>2</code>, <code>3</code>, <code>6</code>, or <code>7</code>
as the optional <code>mode</code> argument:


<PRE>
mysql&#62; SELECT YEAR('2000-01-01'), WEEK('2000-01-01',0);
        -&#62; 2000, 0
</PRE>

One might argue that MySQL should return <code>52</code> for the <code>WEEK()</code>
function, because the given date actually occurs in the 52nd week of 1999.  We
decided to return <code>0</code> instead as we want the function to return ``the week
number in the given year.''  This makes the usage of the <code>WEEK()</code>
function reliable when combined with other functions that extract a
date part from a date.

If you would prefer the result to be evaluated with respect to the year
that contains the first day of the week for the given date, you should use
<code>2</code>, <code>3</code>, <code>6</code>, or <code>7</code> as the optional <code>mode</code> argument.


<PRE>
mysql&#62; SELECT WEEK('2000-01-01',2);
        -&#62; 52
</PRE>

Alternatively, use the <code>YEARWEEK()</code> function:


<PRE>
mysql&#62; SELECT YEARWEEK('2000-01-01');
        -&#62; 199952
mysql&#62; SELECT MID(YEARWEEK('2000-01-01'),5,2);
        -&#62; '52'
</PRE>

<br><br><br><A NAME="IDX1404"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>WEEKDAY(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>WEEKDAY(date)</b></code><DD></A>
Returns the weekday index for
<code>date</code> (<code>0</code> = Monday, <code>1</code> = Tuesday, ... <code>6</code> = Sunday).


<PRE>
mysql&#62; SELECT WEEKDAY('1998-02-03 22:23:00');
        -&#62; 1
mysql&#62; SELECT WEEKDAY('1997-11-05');
        -&#62; 2
</PRE>

<br><br><br><A NAME="IDX1405"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>WEEKOFYEAR(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>WEEKOFYEAR(date)</b></code><DD></A>
Returns the calendar week of the date as a number in the
range from <code>1</code> to <code>53</code>.


<PRE>
mysql&#62; SELECT WEEKOFYEAR('1998-02-20');
        -&#62; 8
</PRE>

<code>WEEKOFYEAR()</code> is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1406"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>YEAR(date)</code></b></td>
 </tr>
</table>
<br>
<code><b>YEAR(date)</b></code><DD></A>
Returns the year for <code>date</code>, in the range <code>1000</code> to <code>9999</code>.


<PRE>
mysql&#62; SELECT YEAR('98-02-03');
        -&#62; 1998
</PRE>

<DT><code><b>YEARWEEK(date)</b></code><DD>
<DT><code><b>YEARWEEK(date,start)</b></code><DD>
Returns year and week for a date.  The <code>start</code> argument works exactly
like the <code>start</code> argument to <code>WEEK()</code>.  The year in the
result may be
different from the year in the date argument for the first and the last
week of the year.


<PRE>
mysql&#62; SELECT YEARWEEK('1987-01-01');
        -&#62; 198653
</PRE>

Note that the week number is different from what the <code>WEEK()</code>
function would return (<code>0</code>) for optional arguments <code>0</code> or <code>1</code>,
as <code>WEEK()</code> then returns the week in the context of the given year.

</DL>



<H2><A NAME="Fulltext_Search" HREF="index.html#Fulltext_Search">13.6  Full-text Search Functions</A></H2>

<P>
<A NAME="IDX1407"></A>
<A NAME="IDX1408"></A>
<A NAME="IDX1409"></A>

</P>

<DL COMPACT>

<br><br><br><A NAME="IDX1410"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION] )</code></b></td>
 </tr>
</table>
<br>
<code><b>MATCH (col1,col2,...) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION] )</b></code><DD></A>
 

As of MySQL 3.23.23, MySQL has support for full-text indexing
and searching.  A full-text index in MySQL is an index of type
<code>FULLTEXT</code>.  <code>FULLTEXT</code> indexes are used with <code>MyISAM</code> tables
only and can be created from <code>CHAR</code>, <code>VARCHAR</code>,
or <code>TEXT</code> columns at <code>CREATE TABLE</code> time or added later with
<code>ALTER TABLE</code> or <code>CREATE INDEX</code>.  For large datasets, it will be
much faster to load your data into a table that has no <code>FULLTEXT</code>
index, then create the index with <code>ALTER TABLE</code> (or
<code>CREATE INDEX</code>).  Loading data into a table that already has a
<code>FULLTEXT</code> index could be significantly slower.

Constraints on full-text searching are listed in section 13.6.3  Full-text Restrictions.

</DL>

<P>
Full-text searching is performed with the <code>MATCH()</code> function.

</P>

<PRE>
mysql&#62; CREATE TABLE articles (
    -&#62;   id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&#62;   title VARCHAR(200),
    -&#62;   body TEXT,
    -&#62;   FULLTEXT (title,body)
    -&#62; );
Query OK, 0 rows affected (0.00 sec)

mysql&#62; INSERT INTO articles (title,body) VALUES
    -&#62; ('MySQL Tutorial','DBMS stands for DataBase ...'),
    -&#62; ('How To Use MySQL Efficiently','After you went through a ...'),
    -&#62; ('Optimizing MySQL','In this tutorial we will show ...'),
    -&#62; ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
    -&#62; ('MySQL vs. YourSQL','In the following database comparison ...'),
    -&#62; ('MySQL Security','When configured properly, MySQL ...');
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&#62; SELECT * FROM articles
    -&#62; WHERE MATCH (title,body) AGAINST ('database');
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)
</PRE>

<P>
The <code>MATCH()</code> function performs a natural language search for a string
against a text collection. A collection is a set of one or more columns
included in a <code>FULLTEXT</code> index.  The search string is given as the
argument to <code>AGAINST()</code>.  The search is performed in case-insensitive
fashion.  For every row in the table, <code>MATCH()</code> returns a relevance
value, that is, a similarity measure between the search string and the text
in that row in the columns named in the <code>MATCH()</code> list.

</P>
<P>
When <code>MATCH()</code> is used in a <code>WHERE</code> clause, as in the preceding
example,
the rows returned are automatically sorted with the highest relevance first.
Relevance values are non-negative floating-point numbers.  Zero relevance
means no similarity.  Relevance is computed based on the number of words
in the row, the number of unique words in that row, the total number of
words in the collection, and the number of documents (rows) that contain
a particular word.

</P>
<P>
For natural-language full-text searches, it is a requirement that the
columns named in the <code>MATCH()</code> function be the same columns included in
some <code>FULLTEXT</code> index in your table.  For the preceding query, note
that the columns named in the <code>MATCH()</code> function (<code>title</code> and
<code>body</code>) are the same as those named in the definition of the
<code>article</code> table's <code>FULLTEXT</code> index.  If you wanted to search the
<code>title</code> or <code>body</code> separately, you would need to create
<code>FULLTEXT</code> indexes for each column.

</P>
<P>
It is also possible to perform a boolean search or a search with query
expansion.  These search types are described in section 13.6.1  Boolean Full-text Searches and
section 13.6.2  Full-text Searches with Query Expansion.

</P>
<P>
The preceding example is a basic illustration showing how to use the
<code>MATCH()</code> function where rows are returned in order of decreasing
relevance.  The next example shows how to retrieve the relevance values
explicitly.  Returned rows are not ordered because the <code>SELECT</code>
statement includes neither <code>WHERE</code> nor <code>ORDER BY</code> clauses:

</P>

<PRE>
mysql&#62; SELECT id, MATCH (title,body) AGAINST ('Tutorial')
    -&#62; FROM articles;
+----+-----------------------------------------+
| id | MATCH (title,body) AGAINST ('Tutorial') |
+----+-----------------------------------------+
|  1 |                        0.64840710366884 |
|  2 |                                       0 |
|  3 |                        0.66266459031789 |
|  4 |                                       0 |
|  5 |                                       0 |
|  6 |                                       0 |
+----+-----------------------------------------+
6 rows in set (0.00 sec)
</PRE>

<P>
The following example is more complex.  The query returns the relevance values
and it also sorts the rows in order of decreasing relevance. To achieve
this result, you should specify <code>MATCH()</code> twice, once in the
<code>SELECT</code> list and once in the <code>WHERE</code> clause. This causes no
additional overhead, because the MySQL optimizer notices that the
two <code>MATCH()</code> calls are identical and invokes the full-text search
code only once.

</P>

<PRE>
mysql&#62; SELECT id, body, MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root') AS score
    -&#62; FROM articles WHERE MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root');
+----+-------------------------------------+-----------------+
| id | body                                | score           |
+----+-------------------------------------+-----------------+
|  4 | 1. Never run mysqld as root. 2. ... | 1.5055546709332 |
|  6 | When configured properly, MySQL ... |   1.31140957288 |
+----+-------------------------------------+-----------------+
2 rows in set (0.00 sec)
</PRE>

<P>
MySQL uses a very simple parser to split text into words.  A ``word'' is any
sequence of characters consisting of letters, digits, <samp>`''</samp>, or <samp>`_'</samp>.
Some words are ignored in full-text searches:

</P>

<UL>
<LI>

Any word that is too short is ignored.  The default minimum length of
words that will be found by full-text searches is four characters.

<LI>

Words in the stopword list are ignored.  A stopword is a word such as
``the'' or ``some'' that is so common that it is considered to have zero
semantic value.  There is a built-in stopword list.

</UL>

<P>
The default minimum word length and stopword list can be changed as
described in section 13.6.4  Fine-tuning MySQL Full-text Search.

</P>

<P>
Every correct word in the collection and in the query is weighted
according to its significance in the collection or query.  This way, a
word that is present in many documents has a lower weight (and may
even have a zero weight), because it has lower semantic value in this
particular collection.  Conversely, if the word is rare, it receives a
higher weight.  The weights of the words are then combined to compute the
relevance of the row.

</P>
<P>
Such a technique works best with large collections (in fact, it was
carefully tuned this way).  For very small tables, word distribution
does not adequately reflect their semantic value, and this model
may sometimes produce bizarre results. For example, although the word
``MySQL'' is present in every row of the <code>articles</code> table, a search for
the word produces no results:

</P>

<PRE>
mysql&#62; SELECT * FROM articles
    -&#62; WHERE MATCH (title,body) AGAINST ('MySQL');
Empty set (0.00 sec)
</PRE>

<P>
The search result is empty because the word ``MySQL'' is present in at least
50% of the rows.  As such, it is effectively treated as a stopword.
For large datasets, this is the most desirable behavior--a natural language
query should not return every second row from a 1GB table. For small datasets,
it may be less desirable.

</P>
<P>
A word that matches half of rows in a table is less likely to locate relevant
documents.  In fact, it will most likely find plenty of irrelevant documents.
We all know this happens far too often when we are trying to find something on
the Internet with a search engine.  It is with this reasoning that rows
containing the word are assigned a low semantic value for <strong>the
particular dataset in which they occur</strong>.  A given word may exceed the 50%
threshold in one dataset but not another.

</P>
<P>
The 50% threshold has a significant implication when you first try
full-text searching to see how it works: If you create a table and insert only
one or two rows of text into it, every word in the text occurs in at least
50% of the rows. As a result, no searches return any results. Be sure to
insert at least three rows, and preferably many more.

</P>



<H3><A NAME="Fulltext_Boolean" HREF="index.html#Fulltext_Boolean">13.6.1  Boolean Full-text Searches</A></H3>

<P>
As of Version 4.0.1, MySQL can also perform boolean full-text searches using
the <code>IN BOOLEAN MODE</code> modifier.

</P>

<PRE>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body)
    -&#62; AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);
+----+------------------------------+-------------------------------------+
| id | title                        | body                                |
+----+------------------------------+-------------------------------------+
|  1 | MySQL Tutorial               | DBMS stands for DataBase ...        |
|  2 | How To Use MySQL Efficiently | After you went through a ...        |
|  3 | Optimizing MySQL             | In this tutorial we will show ...   |
|  4 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. ... |
|  6 | MySQL Security               | When configured properly, MySQL ... |
+----+------------------------------+-------------------------------------+
</PRE>

<P>
This query retrieves all the rows that contain the word ``MySQL''
but that do <strong>not</strong> contain
the word ``YourSQL''.

</P>
<P>
Some characteristics of boolean full-text searches:

</P>

<UL>
<LI>

They do not use the 50% threshold.

<LI>

They do not automatically sort rows in order of decreasing relevance.  You
can see this from the preceding query result: The row with the highest
relevance is the one that contains ``MySQL'' twice, but it is listed last,
not first.

<LI>

They can work even without a <code>FULLTEXT</code> index, although this would be
<strong>slow</strong>.

</UL>

<P>
The boolean full-text search capability supports the following operators:

</P>

<DL COMPACT>

<DT><code><b>+</b></code><DD>
A leading plus sign indicates that this word <strong>must be</strong>
present in every row returned.

<DT><code><b>-</b></code><DD>
A leading minus sign indicates that this word <strong>must not be</strong>
present in any row returned.

<DT><code><b></b></code><DD>
By default (when neither plus nor minus is specified) the word is optional,
but the rows that contain it will be rated higher. This mimicks the
behavior of <code>MATCH() ... AGAINST()</code> without the <code>IN BOOLEAN
MODE</code> modifier.

<DT><code><b>&#62; &#60;</b></code><DD>
These two operators are used to change a word's contribution to the
relevance value that is assigned to a row.  The <code>&#62;</code> operator
increases the contribution and the <code>&#60;</code> operator decreases it.
See the example below.

<DT><code><b>( )</b></code><DD>
Parentheses are used to group words into subexpressions.
Parenthesized groups can be nested.

<DT><code><b>~</b></code><DD>
A leading tilde acts as a negation operator, causing the word's
contribution to the row relevance to be negative. It's useful for marking
noise words. A row that contains such a word will be rated lower than
others, but will not be excluded altogether, as it would be with the
<code>-</code> operator.

<DT><code><b>*</b></code><DD>
An asterisk is the truncation operator. Unlike the other operators, it
should be <strong>appended</strong> to the word, not prepended.

<DT><code><b>"</b></code><DD>
A phrase that is enclosed within double quote (<samp>`"'</samp>) characters matches only
rows that contain the phrase <strong>literally, as it was typed</strong>.

</DL>

<P>
The following examples demonstrate some search strings that use boolean
full-text operators:

</P>
<DL COMPACT>

<DT><code><b>'apple banana'</b></code><DD>
Find rows that contain at least one of the two words.

<DT><code><b>'+apple +juice'</b></code><DD>
Find rows that contain both words.

<DT><code><b>'+apple macintosh'</b></code><DD>
Find rows that contain the
word ``apple'', but rank rows higher if they also contain ``macintosh''.

<DT><code><b>'+apple -macintosh'</b></code><DD>
Find rows that contain the
word ``apple'' but not ``macintosh''.

<DT><code><b>'+apple +(&#62;turnover &#60;strudel)'</b></code><DD>
Find rows that contain the words
``apple'' and ``turnover'', or ``apple'' and ``strudel'' (in any
order), but rank ``apple turnover'' higher than ``apple strudel''.

<DT><code><b>'apple*'</b></code><DD>
Find rows that contain words such as
``apple'', ``apples'', ``applesauce'', or ``applet''.

<DT><code><b>'"some words"'</b></code><DD>
Find rows that contain the exact phrase ``some words'' (for example, rows
that contain ``some words of wisdom'' but not ``some noise words'').  Note
that the <samp>`"'</samp> characters that surround the phrase are included within
the search string. They are not the quotes that surround the search string
itself.

</DL>



<H3><A NAME="Fulltext_Query_Expansion" HREF="index.html#Fulltext_Query_Expansion">13.6.2  Full-text Searches with Query Expansion</A></H3>

<P>
As of MySQL 4.1.1, full-text search supports query expansion (in particular,
its variant ``blind query expansion''). This is generally useful when a search
phrase is too short, which often means that the user is relying on implied
knowledge that the full-text search engine usually lacks. For example, a user
searching for ``database'' may really mean that ``MySQL'', ``Oracle'',
``DB2'', and ``RDBMS'' all are phrases that should match
``databases'' and should be returned, too. This is implied knowledge.

</P>
<P>
Blind query expansion (also known as automatic relevance feedback) is
enabled by adding <code>WITH QUERY EXPANSION</code> following the search phrase.
It works by performing the search twice, where the search phrase for the
second search is the original search phrase concatenated with the few top
found documents from the first search.  Thus, if one of these documents
contains the word ``databases'' and the word ``MySQL'', the second search
will find the documents that contain the word ``MySQL'' even if they do not
contain the word ``database''.  The following example shows this difference:

</P>

<PRE>
mysql&#62; SELECT * FROM articles
    -&#62; WHERE MATCH (title,body) AGAINST ('database');
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)

mysql&#62; SELECT * FROM articles
    -&#62; WHERE MATCH (title,body)
    -&#62; AGAINST ('database' WITH QUERY EXPANSION);
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
|  3 | Optimizing MySQL  | In this tutorial we will show ...        |
+----+-------------------+------------------------------------------+
3 rows in set (0.00 sec)
</PRE>

<P>
Another example could be searching for books by Georges Simenon about
Maigret, when a user is not sure how to spell ``Maigret''. A search for
``Megre and the reluctant witnesses'' will find only ``Maigret and the
Reluctant Witnesses'' without query expansion.  A search with query
expansion will find all books with the word ``Maigret'' on the second pass.

</P>
<P>
Note: Because blind query expansion tends to increase noise significantly,
by returning non-relevant documents, it's only meaningful to use when a
search phrase is rather short.

</P>



<H3><A NAME="Fulltext_Restrictions" HREF="index.html#Fulltext_Restrictions">13.6.3  Full-text Restrictions</A></H3>


<UL>
<LI>

Full-text searches are supported for <code>MyISAM</code> tables only.
<LI>

As of MySQL 4.1.1, full-text searches can be used with most multi-byte
character sets. The exception is that for Unicode, the <code>utf8</code> character
set can be used, but not the <code>ucs2</code> character set.
<LI>

All columns in a <code>FULLTEXT</code> index must have the same character set.
<LI>

The <code>MATCH()</code> column list must exactly match the column list in some
<code>FULLTEXT</code> index definition for the table, unless this <code>MATCH()</code>
is <code>IN BOOLEAN MODE</code>.
<LI>

The argument to <code>AGAINST()</code> must be a constant string.
</UL>



<H3><A NAME="Fulltext_Fine-tuning" HREF="index.html#Fulltext_Fine-tuning">13.6.4  Fine-tuning MySQL Full-text Search</A></H3>

<P>
The MySQL full-text search capability has few user-tunable parameters yet,
although adding more is very high on the TODO.  You can exert more control
over full-text searching behavior if you have a MySQL source distribution
because some changes require source code modfications.
See section 2.3  MySQL Installation Using a Source Distribution.

</P>
<P>
Note that full-text search was carefully tuned for the best searching
effectiveness.  Modifying the default behavior will, in most cases,
make the search results worse.  Do not alter the MySQL sources
unless you know what you are doing!

</P>
<P>
Most full-text variables described in the following items must be set at
server startup time. For these variables, a server restart is required to
change them and you cannot modify them dynamically while the server is
running.

</P>
<P>
If you modify full-text variables that affect indexing
(<code>ft_min_word_len</code>, <code>ft_max_word_len</code>, or
<code>ft_stopword_file</code>), you must rebuild your <code>FULLTEXT</code> indexes
after making the changes and restarting the server. To rebuild the indexes
in this case, it's sufficent to do a <code>QUICK</code> repair operation:

</P>

<PRE>
mysql&#62; REPAIR TABLE tbl_name QUICK;
</PRE>

<P>
With regard specifically to using the <code>IN BOOLEAN MODE</code> capability, if
you upgrade from MySQL 3.23 to 4.0 or later, it's necessary to replace the
index header as well.  To do this, do a <code>USE_FRM</code> repair operation:

</P>

<PRE>
mysql&#62; REPAIR TABLE tbl_name USE_FRM;
</PRE>

<P>
This is necessary because boolean full-text searches require a flag in the
index header that was not present in MySQL 3.23, and that is not added if
you do only a <code>QUICK</code> repair.  If you attempt a boolean full-text
search without rebuilding the indexes this way, the search will return
incorrect results.

</P>

<UL>

<LI>

The minimum and maximum length of words to be indexed is defined by the
<code>ft_min_word_len</code> and <code>ft_max_word_len</code> system variables
(available as of MySQL 4.0.0).
See section 5.2.3  Server System Variables.
The default minimum value is four characters.  The default maximum depends
on your version of MySQL. If you change either value, you must rebuild your
<code>FULLTEXT</code> indexes.  For example, if you want three-character words to
be searchable, you can set the <code>ft_min_word_len</code> variable by putting
the following lines in an option file:


<PRE>
[mysqld]
ft_min_word_len=3
</PRE>

Then restart the server and rebuild your <code>FULLTEXT</code> indexes.

<LI>

To override the default stopword list, set the <code>ft_stopword_file</code>
system variable (available as of MySQL 4.0.10).
See section 5.2.3  Server System Variables.
The variable value should be the pathname of the file containing the stopword
list, or the empty string to disable stopword filtering. After changing the value, rebuild your <code>FULLTEXT</code> indexes.

<LI>

The 50% threshold for natural language searches is determined by the
particular weighting scheme chosen.  To disable it, look for the following
line in <tt>`myisam/ftdefs.h'</tt>:


<PRE>
#define GWS_IN_USE GWS_PROB
</PRE>

Change the line to this:


<PRE>
#define GWS_IN_USE GWS_FREQ
</PRE>

Then recompile MySQL.
There is no need to rebuild the indexes in this case.
<strong>Note:</strong> By doing this you <strong>severely</strong> decrease MySQL's ability
to provide adequate relevance values for the <code>MATCH()</code> function.
If you really need to search for such common words, it would be better to
search using <code>IN BOOLEAN MODE</code> instead, which does not observe the 50%
threshold.

<LI>

To change the operators used for boolean full-text searches, set the
<code>ft_boolean_syntax</code> system variable (available as of MySQL 4.0.1).  The
variable also can be changed while the server is running, but you must have
the <code>SUPER</code> privilege to do so.
No index rebuilding is necessary.
section 5.2.3  Server System Variables describes the rules that define how to set this
variable.

</UL>



<H3><A NAME="Fulltext_TODO" HREF="index.html#Fulltext_TODO">13.6.5  Full-text Search TODO</A></H3>


<UL>
<LI>Improved performance for all <code>FULLTEXT</code> operations.

<LI>Proximity operators

<LI>Support for ``always-index words.'' These could be any strings

the user wants to treat as words, such as ``C++'', ``AS/400'', or ``TCP/IP''.
<LI>Support for full-text search in <code>MERGE</code> tables.

<LI>Support for UCS-2.

<LI>Make the stopword list dependent on the language of the dataset.

<LI>Stemming (dependent on the language of the dataset).

<LI>Generic user-suppliable UDF preparser.

<LI>Make the model more flexible (by adding some adjustable

parameters to <code>FULLTEXT</code> in <code>CREATE TABLE</code> and <code>ALTER TABLE</code>
statements).
</UL>



<H2><A NAME="Cast_Functions" HREF="index.html#Cast_Functions">13.7  Cast Functions</A></H2>

<DL COMPACT>

<br><br><br><A NAME="IDX1411"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CAST(expr AS type)</code></b></td>
 </tr>
</table>
<br>
<code><b>CAST(expr AS type)</b></code><DD></A>
 <br><br><br><A NAME="IDX1412"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CONVERT(expr,type)</code></b></td>
 </tr>
</table>
<br>
<code><b>CONVERT(expr,type)</b></code><DD></A>
<DT><code><b>CONVERT(expr USING transcoding_name)</b></code><DD>
The <code>CAST()</code> and <code>CONVERT()</code> functions may be used to take a
value of one type and produce a value of another type.

The <code>type</code> value can be one of the following:


<UL>
<LI>

<code>BINARY</code>
<LI>

<code>CHAR</code>
<LI>

<code>DATE</code>
<LI>

<code>DATETIME</code>
<LI>

<code>SIGNED [INTEGER]</code>
<LI>

<code>TIME</code>
<LI>

<code>UNSIGNED [INTEGER]</code>
</UL>

<code>CAST()</code> and <code>CONVERT()</code> are available as of MySQL 4.0.2.
The <code>CHAR</code> conversion type is available as of 4.0.6.
The <code>USING</code> form of <code>CONVERT()</code> is available as of 4.1.0.

<code>CAST()</code> and <code>CONVERT(... USING ...)</code> are SQL-99 syntax.
The non-<code>USING</code> form of <code>CONVERT()</code> is ODBC syntax.

<code>CONVERT()</code> with <code>USING</code> is used to convert data between different
character sets.  In MySQL, transcoding names are the same as the
corresponding character set names.  For example, this statement converts
the string <code>'abc'</code> in the server's default character set to the
corresponding string in the <code>utf8</code> character set:


<PRE>
SELECT CONVERT('abc' USING utf8);
</PRE>

</DL>

<P>
The cast functions are useful when you want to create a column with
a specific type in a <code>CREATE ... SELECT</code> statement:

</P>

<PRE>
CREATE TABLE new_table SELECT CAST('2000-01-01' AS DATE);
</PRE>

<P>
The functions also can be useful for sorting <code>ENUM</code> columns in lexical
order. Normally sorting of <code>ENUM</code> columns occurs using the internal
numeric values. Casting the values to <code>CHAR</code> results in a lexical
sort:

</P>

<PRE>
SELECT enum_col FROM tbl_name ORDER BY CAST(enum_col AS CHAR);
</PRE>

<P>
<code>CAST(str AS BINARY)</code> is the same thing as <code>BINARY str</code>.
<code>CAST(expr AS CHAR)</code> treats the expression as a string with the
default character set.

</P>
<P>
<strong>Note:</strong> In MysQL 4.0, a <code>CAST()</code> to <code>DATE</code>,
<code>DATETIME</code>, or <code>TIME</code> only marks the column to be a specific
type but doesn't change the value of the column.

</P>
<P>
As of MySQL 4.1.0, the value is converted to the correct column type when
it's sent to the user (this is a feature of how the new protocol in 4.1
sends date information to the client):

</P>

<PRE>
mysql&#62; SELECT CAST(NOW() AS DATE);
       -&#62; 2003-05-26
</PRE>

<P>
In later MySQL versions (probably 4.1.2 or 5.0) we will fix <code>CAST</code>
so that it also changes the result if you use it as part of a more complex expression
such as <code>CONCAT('Date: ',CAST(NOW() AS DATE))</code>.

</P>
<P>
You should not use <code>CAST()</code> to extract data in different formats but
instead use string functions like <code>LEFT()</code> or
<code>EXTRACT()</code>. See section 13.5  Date and Time Functions.

</P>
<P>
To cast a string to a numeric value, you don't normally have to do
anything; just use the string value as it were a number:

</P>

<PRE>
mysql&#62; SELECT 1+'1';
       -&#62; 2
</PRE>

<P>
If you use a number in string context, the number automatically will be
converted to a <code>BINARY</code> string.

</P>

<PRE>
mysql&#62; SELECT CONCAT('hello you ',2);
        -&#62; 'hello you 2'
</PRE>

<P>
MySQL supports arithmetic with both signed and unsigned 64-bit values.
If you are using numerical operators (like <code>+</code>) and one of the
operands is an unsigned integer, the result will be unsigned.
You can override this by using the <code>SIGNED</code> and <code>UNSIGNED</code>
cast operators to cast the operation to a signed or
unsigned 64-bit integer, respectively.

</P>

<PRE>
mysql&#62; SELECT CAST(1-2 AS UNSIGNED)
        -&#62; 18446744073709551615
mysql&#62; SELECT CAST(CAST(1-2 AS UNSIGNED) AS SIGNED);
        -&#62; -1
</PRE>

<P>
Note that if either operand is a floating-point value, the result is
a floating-point value and is not affected by the preceding rule.
(In this context, <code>DECIMAL</code> column values are regarded as
floating-point values.)

</P>

<PRE>
mysql&#62; SELECT CAST(1 AS UNSIGNED) - 2.0;
        -&#62; -1.0
</PRE>

<P>
If you are using a string in an arithmetic operation, this is converted
to a floating-point number.

</P>
<P>
The handing of unsigned values was changed in MySQL 4.0 to be able to
support <code>BIGINT</code> values properly. If you have some code that you
want to run in both MySQL 4.0 and 3.23, you probably can't
use the <code>CAST()</code> function. You can use the following technique to get
a signed result when subtracting two unsigned integer columns <code>ucol1</code> and
<code>ucol2</code>:

</P>

<PRE>
mysql&#62; SELECT (ucol1+0.0)-(ucol1+0.0);
</PRE>

<P>
The idea is that the columns are converted to floating-point values before
the subtraction occurs.

</P>
<P>
If you have a problem with <code>UNSIGNED</code> columns in old MySQL
applications when porting them to MySQL 4.0, you can use the
<code>--sql-mode=NO_UNSIGNED_SUBTRACTION</code> option when starting
<code>mysqld</code>.  However, as long as you use this option, you will not
be able to make efficient use of the <code>BIGINT UNSIGNED</code> column type.

</P>



<H2><A NAME="Other_Functions" HREF="index.html#Other_Functions">13.8  Other Functions</A></H2>



<H3><A NAME="Bit_functions" HREF="index.html#Bit_functions">13.8.1  Bit Functions</A></H3>

<P>
<A NAME="IDX1413"></A>
<A NAME="IDX1414"></A>
<A NAME="IDX1415"></A>

</P>
<P>
MySQL uses <code>BIGINT</code> (64-bit) arithmetic for bit operations, so
these operators have a maximum range of 64 bits.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1416"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>|</code></b></td>
 </tr>
</table>
<br>
<code><b>|</b></code><DD></A>
 <A NAME="IDX1417"></A>
 
Bitwise OR:


<PRE>
mysql&#62; SELECT 29 | 15;
        -&#62; 31
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1418"></A>
<br><br><br><A NAME="IDX1419"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#38;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#38;</b></code><DD></A>
Bitwise AND:


<PRE>
mysql&#62; SELECT 29 &#38; 15;
        -&#62; 13
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1420"></A>
<br><br><br><A NAME="IDX1421"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>^</code></b></td>
 </tr>
</table>
<br>
<code><b>^</b></code><DD></A>
Bitwise XOR:


<PRE>
mysql&#62; SELECT 1 ^ 1;
        -&#62; 0
mysql&#62; SELECT 1 ^ 0;
        -&#62; 1
mysql&#62; SELECT 11 ^ 3;
        -&#62; 8
</PRE>

The result is an unsigned 64-bit integer.

<code>XOR</code> was added in MySQL 4.0.2.

<br><br><br><A NAME="IDX1422"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#60;&#60;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#60;&#60;</b></code><DD></A>
Shifts a longlong (<code>BIGINT</code>) number to the left.


<PRE>
mysql&#62; SELECT 1 &#60;&#60; 2;
        -&#62; 4
</PRE>

The result is an unsigned 64-bit integer.

<br><br><br><A NAME="IDX1423"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>&#62;&#62;</code></b></td>
 </tr>
</table>
<br>
<code><b>&#62;&#62;</b></code><DD></A>
Shifts a longlong (<code>BIGINT</code>) number to the right.


<PRE>
mysql&#62; SELECT 4 &#62;&#62; 2;
        -&#62; 1
</PRE>

The result is an unsigned 64-bit integer.

<br><br><br><A NAME="IDX1424"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>~</code></b></td>
 </tr>
</table>
<br>
<code><b>~</b></code><DD></A>
Invert all bits.


<PRE>
mysql&#62; SELECT 5 &#38; ~1;
        -&#62; 4
</PRE>

The result is an unsigned 64-bit integer.

<br><br><br><A NAME="IDX1425"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIT_COUNT(N)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIT_COUNT(N)</b></code><DD></A>
Returns the number of bits that are set in the argument <code>N</code>.


<PRE>
mysql&#62; SELECT BIT_COUNT(29);
        -&#62; 4
</PRE>

</DL>



<H3><A NAME="Encryption_functions" HREF="index.html#Encryption_functions">13.8.2  Encryption Functions</A></H3>

<P>
<A NAME="IDX1426"></A>
<A NAME="IDX1427"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1428"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>AES_ENCRYPT(str,key_str)</code></b></td>
 </tr>
</table>
<br>
<code><b>AES_ENCRYPT(str,key_str)</b></code><DD></A>
 <br><br><br><A NAME="IDX1429"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>AES_DECRYPT(str,key_str)</code></b></td>
 </tr>
</table>
<br>
<code><b>AES_DECRYPT(str,key_str)</b></code><DD></A>
These functions allow encryption/decryption of data using the official
AES (Advanced Encryption Standard) algorithm, previously known as Rijndael.
Encoding with a 128-bit key length is used, but you can extend it up to
256 bits by modifying the source. We chose 128 bits because it is much
faster and it is usually secure enough.

The input arguments may be any length. If either argument is <code>NULL</code>,
the result of this function is also <code>NULL</code>.

Because AES is a block-level algorithm, padding is used to encode uneven length
strings and so the result string length may be calculated as
<code>16*(trunc(string_length/16)+1)</code>.

If <code>AES_DECRYPT()</code> detects invalid data or incorrect padding, it
returns <code>NULL</code>. However, it is possible for <code>AES_DECRYPT()</code>
to return a non-<code>NULL</code> value (possibly garbage) if the input data or
the key is invalid.

You can use the AES functions to store data in an encrypted form by
modifying your queries:


<PRE>
INSERT INTO t VALUES (1,AES_ENCRYPT('text','password'));
</PRE>

You can get even more security by not transferring the key over the
connection for each query, which can be accomplished by storing it in a
server-side variable at connection time. For example:

<PRE>
SELECT @password:='my password';
INSERT INTO t VALUES (1,AES_ENCRYPT('text',@password));
</PRE>

<code>AES_ENCRYPT()</code> and <code>AES_DECRYPT()</code> were added in MySQL 4.0.2,
and can be considered the most cryptographically secure encryption
functions currently available in MySQL.

<br><br><br><A NAME="IDX1430"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DECODE(crypt_str,pass_str)</code></b></td>
 </tr>
</table>
<br>
<code><b>DECODE(crypt_str,pass_str)</b></code><DD></A>
Descrypts the encrypted string <code>crypt_str</code> using <code>pass_str</code> as the
password.  <code>crypt_str</code> should be a string returned from
<code>ENCODE()</code>.

<br><br><br><A NAME="IDX1431"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ENCODE(str,pass_str)</code></b></td>
 </tr>
</table>
<br>
<code><b>ENCODE(str,pass_str)</b></code><DD></A>
Encrypt <code>str</code> using <code>pass_str</code> as the password.
To decrypt the result, use <code>DECODE()</code>.

The result is a binary string of the same length as <code>string</code>.
If you want to save it in a column, use a <code>BLOB</code> column type.

<br><br><br><A NAME="IDX1432"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DES_DECRYPT(str_to_decrypt [, key_str])</code></b></td>
 </tr>
</table>
<br>
<code><b>DES_DECRYPT(str_to_decrypt [, key_str])</b></code><DD></A>
Decrypts a string encrypted with <code>DES_ENCRYPT()</code>.
On error, this function returns <code>NULL</code>.

Note that this function works only if MySQL has been configured with
SSL support. See section 5.5.8  Using Secure Connections.

If no <code>key_str</code> argument is given, <code>DES_DECRYPT()</code> examines
the first byte of the encrypted string to determine the DES key number
that was used to encrypt the original string, and then reads the key
from the DES key file to decrypt the message.  For this to work,
the user must have the <code>SUPER</code> privilege. The key file can be specified
with the <code>--des-key-file</code> server option.

If you pass this function a <code>key_str</code> argument, that string
is used as the key for decrypting the message.

If the <code>str_to_decrypt</code> argument doesn't look like an encrypted string,
MySQL will return the given <code>str_to_decrypt</code>.

<br><br><br><A NAME="IDX1433"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DES_ENCRYPT(str_to_encrypt [, (key_num | key_str) ] )</code></b></td>
 </tr>
</table>
<br>
<code><b>DES_ENCRYPT(str_to_encrypt [, (key_num | key_str) ] )</b></code><DD></A>
Encrypts the string with the given key using the Triple-DES algorithm.
On error, this function returns <code>NULL</code>.

Note that this function works only if MySQL has been configured with
SSL support. See section 5.5.8  Using Secure Connections.

The encryption key to use is chosen based on the second argument to
<code>DES_ENCRYPT()</code>, if one was given:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Argument</strong> </TD><TD> <strong>Description</strong>
</TD></TR>
<TR><TD>No argument </TD><TD>
The first key from the DES key file is used.
</TD></TR>
<TR><TD><code>key_num</code> </TD><TD>
The given key number (0-9) from the DES key file is used.
</TD></TR>
<TR><TD><code>key_str</code> </TD><TD>
The given key string is used to encrypt <code>str_to_encrypt</code>.
</TD></TR>
</TABLE>

The key file can be specified with the <code>--des-key-file</code> server option.

The return string is a binary string where the first character
is <code>CHAR(128 | key_num)</code>.

The 128 is added to make it easier to recognize an encrypted key.
If you use a string key, <code>key_num</code> will be 127.

The string length for the result will be
<code>new_len = orig_len + (8-(orig_len % 8))+1</code>.

The DES key file has the following format:


<PRE>
key_num des_key_str
key_num des_key_str
</PRE>

Each <code>key_num</code> must be a number in the range from <code>0</code> to <code>9</code>.  Lines in
the file may be in any order.  <code>des_key_str</code> is the string that
will be used to encrypt the message.  Between the number and the key there
should be at least one space.  The first key is the default key that is
used if you don't specify any key argument to <code>DES_ENCRYPT()</code>

You can tell MySQL to read new key values from the key file with the
<code>FLUSH DES_KEY_FILE</code> command.  This requires the <code>RELOAD</code>
privilege.

One benefit of having a set of default keys is that it gives applications
a way to check for the existence of encrypted column values, without giving
the end user the right to decrypt those values.


<PRE>
mysql&#62; SELECT customer_address FROM customer_table WHERE
       crypted_credit_card = DES_ENCRYPT('credit_card_number');
</PRE>

<br><br><br><A NAME="IDX1434"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>ENCRYPT(str[,salt])</code></b></td>
 </tr>
</table>
<br>
<code><b>ENCRYPT(str[,salt])</b></code><DD></A>
Encrypt <code>str</code> using the Unix <code>crypt()</code> system call. The
<code>salt</code> argument should be a string with two characters.
(As of MySQL 3.22.16, <code>salt</code> may be longer than two characters.)


<PRE>
mysql&#62; SELECT ENCRYPT('hello');
        -&#62; 'VxuFAJXVARROc'
</PRE>

<code>ENCRYPT()</code> ignores all but the first 8 characters of <code>str</code>, at
least on some systems.  This behavior is determined by the implementation
of the underlying <code>crypt()</code> system call.

If <code>crypt()</code> is not available on your system, <code>ENCRYPT()</code> always
returns <code>NULL</code>.  Because of this, we recommend that you use <code>MD5()</code>
or <code>SHA1()</code> instead, because these two functions exist on all platforms.

<br><br><br><A NAME="IDX1435"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MD5(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>MD5(str)</b></code><DD></A>
Calculates an MD5 128-bit checksum for the string. The value is returned
as a string of 32 hex digits,
or <code>NULL</code> if the argument was <code>NULL</code>.
The return value can, for example, be used as a hash key.


<PRE>
mysql&#62; SELECT MD5('testing');
        -&#62; 'ae2b1fca515949e5d54fb22b8ed95575'
</PRE>

This is the "RSA Data Security, Inc. MD5 Message-Digest Algorithm".

<A NAME="IDX1436"></A>
<br><br><br><A NAME="IDX1437"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>PASSWORD(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>PASSWORD(str)</b></code><DD></A>
<DT><code><b>OLD_PASSWORD(str)</b></code><DD>
Calculates and returns a password string from the plaintext password
<code>str</code>, or <code>NULL</code> if the argument was <code>NULL</code>. This is
the function that is used for encrypting MySQL passwords for storage
in the <code>Password</code> column of the <code>user</code> grant table.


<PRE>
mysql&#62; SELECT PASSWORD('badpwd');
        -&#62; '7f84554057dd964b'
</PRE>

<A NAME="IDX1438"></A>
<code>PASSWORD()</code> encryption is one-way (not reversible).

<code>PASSWORD()</code> does not perform password encryption in the same way that
Unix passwords are encrypted. See <code>ENCRYPT()</code>.

<strong>Note:</strong>
The <code>PASSWORD()</code> function is used by the authentication system in
MySQL Server, you should <em>not</em> use it in your own applications.
For that purpose, use <code>MD5()</code> or <code>SHA1()</code> instead.
Also see RFC 2195 for more information about handling passwords
and authentication securely in your application.

<A NAME="IDX1439"></A>
<br><br><br><A NAME="IDX1440"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SHA1(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>SHA1(str)</b></code><DD></A>
<DT><code><b>SHA(str)</b></code><DD>
Calculates an SHA1 160-bit checksum for the string, as described in
RFC 3174 (Secure Hash Algorithm). The value is returned as a string of 40 hex
digits, or <code>NULL</code> if the argument was <code>NULL</code>.
One of the possible uses for this function is as a hash key. You can
also use it as cryptographically safe function for storing passwords.


<PRE>
mysql&#62; SELECT SHA1('abc');
        -&#62; 'a9993e364706816aba3e25717850c26c9cd0d89d'
</PRE>

<code>SHA1()</code> was added in MySQL 4.0.2, and can be considered
a cryptographically more secure equivalent of <code>MD5()</code>.
<code>SHA()</code> is synonym for <code>SHA1()</code>.

</DL>



<H3><A NAME="Information_functions" HREF="index.html#Information_functions">13.8.3  Information Functions</A></H3>

<P>
<A NAME="IDX1441"></A>
<A NAME="IDX1442"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1443"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BENCHMARK(count,expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>BENCHMARK(count,expr)</b></code><DD></A>
 
The <code>BENCHMARK()</code> function executes the expression <code>expr</code>
repeatedly <code>count</code> times.  It may be used to time how fast MySQL
processes the expression.  The result value is always <code>0</code>.  The intended
use is from within the <code>mysql</code> client, which reports query execution times:


<PRE>
mysql&#62; SELECT BENCHMARK(1000000,ENCODE('hello','goodbye'));
+----------------------------------------------+
| BENCHMARK(1000000,ENCODE('hello','goodbye')) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</PRE>

The time reported is elapsed time on the client end, not CPU time on the
server end.  It may be advisable to execute <code>BENCHMARK()</code> several
times, and interpret the result with regard to how heavily loaded the
server machine is.

<br><br><br><A NAME="IDX1444"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CHARSET(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>CHARSET(str)</b></code><DD></A>
Returns the character set of the string argument.


<PRE>
mysql&#62; SELECT CHARSET(_utf8'abc');
        -&#62; 'utf8'
</PRE>

<code>CHARSET()</code> was added in MySQL 4.1.0.

<br><br><br><A NAME="IDX1445"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COERCIBILITY(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>COERCIBILITY(str)</b></code><DD></A>
Returns the collation coercibility value of the string argument.


<PRE>
mysql&#62; SELECT COERCIBILITY('abc' COLLATE latin1_swedish_ci);
        -&#62; 0
mysql&#62; SELECT COERCIBILITY('abc');
        -&#62; 3
mysql&#62; SELECT COERCIBILITY(USER());
        -&#62; 2
</PRE>

The return values have the following meanings:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Coercibility</strong> </TD><TD> <strong>Meaning</strong>
</TD></TR>
<TR><TD><code>0</code> </TD><TD> Explicit collation
</TD></TR>
<TR><TD><code>1</code> </TD><TD> No collation
</TD></TR>
<TR><TD><code>2</code> </TD><TD> Implicit collation
</TD></TR>
<TR><TD><code>3</code> </TD><TD> Coercible
</TD></TR>
</TABLE>

Lower values have higher precedence.

<code>COERCIBILITY()</code> was added in MySQL 4.1.1.

<br><br><br><A NAME="IDX1446"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COLLATION(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>COLLATION(str)</b></code><DD></A>
Returns the collation for the character set of the string argument.


<PRE>
mysql&#62; SELECT COLLATION('abc');
        -&#62; 'latin1_swedish_ci'
mysql&#62; SELECT COLLATION(_utf8'abc');
        -&#62; 'utf8_general_ci'
</PRE>

<code>COLLATION()</code> was added in MySQL 4.1.0.

<br><br><br><A NAME="IDX1447"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CONNECTION_ID()</code></b></td>
 </tr>
</table>
<br>
<code><b>CONNECTION_ID()</b></code><DD></A>
Returns the connection ID (thread ID) for the connection.
Every connection has its own unique ID.


<PRE>
mysql&#62; SELECT CONNECTION_ID();
        -&#62; 23786
</PRE>

<br><br><br><A NAME="IDX1448"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>CURRENT_USER()</code></b></td>
 </tr>
</table>
<br>
<code><b>CURRENT_USER()</b></code><DD></A>
Returns the username and hostname combination that the current session was authenticated
as. This value corresponds to the account that is used for assessing your
access privileges. It may be different than the value of <code>USER()</code>.


<PRE>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
mysql&#62; SELECT * FROM mysql.user;
ERROR 1044: Access denied for user: '@localhost' to
database 'mysql'
mysql&#62; SELECT CURRENT_USER();
        -&#62; '@localhost'
</PRE>

The example illustrates that although the client specified a username of
<code>davida</code> (as indicated by the value of the <code>USER()</code> function),
the server authenticated the client using an anonymous user account (as seen by
the empty username part of the <code>CURRENT_USER()</code> value). One way this might
occur is that there is no account listed in the grant tables for
<code>davida</code>.

<br><br><br><A NAME="IDX1449"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>DATABASE()</code></b></td>
 </tr>
</table>
<br>
<code><b>DATABASE()</b></code><DD></A>
Returns the current database name.


<PRE>
mysql&#62; SELECT DATABASE();
        -&#62; 'test'
</PRE>

If there is no current database, <code>DATABASE()</code> returns <code>NULL</code> as
of MySQL 4.1.1, and the empty string before that.

<A NAME="IDX1450"></A>
<br><br><br><A NAME="IDX1451"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FOUND_ROWS()</code></b></td>
 </tr>
</table>
<br>
<code><b>FOUND_ROWS()</b></code><DD></A>
A <code>SELECT</code> statement may include a <code>LIMIT</code> clause to restrict the
number of rows the server returns to the client.
In some cases, it is desirable to know how many rows the statement would have
returned without the <code>LIMIT</code>, but without running the statement again.
To get this row count, include a <code>SQL_CALC_FOUND_ROWS</code> option in the
<code>SELECT</code> statement, then invoke <code>FOUND_ROWS()</code> afterward:


<PRE>
mysql&#62; SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name
       WHERE id &#62; 100 LIMIT 10;
mysql&#62; SELECT FOUND_ROWS();
</PRE>

The second <code>SELECT</code> will return a number indicating how many rows the
first <code>SELECT</code> would have returned had it been written without the
<code>LIMIT</code> clause.
(If the preceding <code>SELECT</code> statement does not include the
<code>SQL_CALC_FOUND_ROWS</code> option, then <code>FOUND_ROWS()</code> may return
a different result when <code>LIMIT</code> is used than when it is not.)

Note that if you are using <code>SELECT SQL_CALC_FOUND_ROWS</code>, MySQL must
calculate how many rows are in the full result set.  However, this is
faster than running the query again without <code>LIMIT</code>, because the result
set need not be sent to the client.

<code>SQL_CALC_FOUND_ROWS</code> and <code>FOUND_ROWS()</code> can be useful in situations
when you want to restrict the number of rows that a query returns, but also
determine the number of rows in the full result set without running the query
again. An example is a Web script that presents a paged display containing
links to the pages that show other sections of a search result. Using
<code>FOUND_ROWS()</code> allows you to determine how many other pages are needed
for the rest of the result.

The use of <code>SQL_CALC_FOUND_ROWS</code> and <code>FOUND_ROWS()</code> is more complex
for <code>UNION</code> queries than for simple <code>SELECT</code> statements, because
<code>LIMIT</code> may occur at multiple places in a <code>UNION</code>. It may be applied
to individual <code>SELECT</code> statements in the <code>UNION</code>, or global to the
<code>UNION</code> result as a whole.

The intent of <code>SQL_CALC_FOUND_ROWS</code> for <code>UNION</code> is that it should
return the row count that would be returned without a global <code>LIMIT</code>.
The conditions for use of <code>SQL_CALC_FOUND_ROWS</code> with <code>UNION</code> are:


<UL>

<LI>

The <code>SQL_CALC_FOUND_ROWS</code> keyword must appear in the first <code>SELECT</code>
of the <code>UNION</code>.

<LI>

The value of <code>FOUND_ROWS()</code> is exact only if <code>UNION ALL</code> is used.
If <code>UNION</code> without <code>ALL</code> is used, duplicate removal occurs and the
value of <code>FOUND_ROWS()</code> is only approximate.

<LI>

If no <code>LIMIT</code> is present in the <code>UNION</code>, <code>SQL_CALC_FOUND_ROWS</code>
is ignored and returns the number of rows in the temporary table that is
created to process the <code>UNION</code>.

</UL>

<code>SQL_CALC_FOUND_ROWS</code> and <code>FOUND_ROWS()</code> are available starting
at MySQL 4.0.0.

<br><br><br><A NAME="IDX1452"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>LAST_INSERT_ID()</code></b></td>
 </tr>
</table>
<br>
<code><b>LAST_INSERT_ID()</b></code><DD></A>
<DT><code><b>LAST_INSERT_ID(expr)</b></code><DD>
Returns the last automatically generated value that was inserted into
an <code>AUTO_INCREMENT</code> column.


<PRE>
mysql&#62; SELECT LAST_INSERT_ID();
        -&#62; 195
</PRE>

The last ID that was generated is maintained in the server on a
per-connection basis. This means the value the function returns to a given
client is the most recent <code>AUTO_INCREMENT</code> value generated by that
client. The value cannot be affected by other clients, even if they generate
<code>AUTO_INCREMENT</code> values of their own. This behavior ensures that you can
retrieve your own ID without concern for the activity of other clients, and
without the need for locks or transactions.

The value of <code>LAST_INSERT_ID()</code> is not changed if you
update the <code>AUTO_INCREMENT</code> column of a row with a
non-magic value (that is, a value that is not <code>NULL</code> and not <code>0</code>).

If you insert many rows at the same time with an insert statement,
<code>LAST_INSERT_ID()</code> returns the value for the first inserted row.
The reason for this is to make it possible to easily reproduce
the same <code>INSERT</code> statement against some other server.

<A NAME="IDX1453"></A>
If <code>expr</code> is given as an argument to <code>LAST_INSERT_ID()</code>, then
the value of the argument is returned by the function, and is set as the
next value to be returned by <code>LAST_INSERT_ID()</code>.  This can be used
to simulate sequences:


<UL>
<LI>

Create a table to hold the sequence counter and initialize it:


<PRE>
mysql&#62; CREATE TABLE sequence (id INT NOT NULL);
mysql&#62; INSERT INTO sequence VALUES (0);
</PRE>

<LI>

Use the table to generate sequence numbers like this:


<PRE>
mysql&#62; UPDATE sequence SET id=LAST_INSERT_ID(id+1);
mysql&#62; SELECT LAST_INSERT_ID();
</PRE>

The <code>UPDATE</code> statement increments the sequence counter and causes the
next call to <code>LAST_INSERT_ID()</code> to return the updated value.
The <code>SELECT</code> statement retrieves that value.
The C API function
<code>mysql_insert_id()</code> can also be used to get the value.
See section <A HREF="manual_Clients.html#mysql_insert_id">20.2.3.32  <code>mysql_insert_id()</code></A>.

</UL>

You can generate sequences without calling <code>LAST_INSERT_ID()</code>, but the
utility of using the function this way is that the ID value is maintained in
the server as the last automatically generated value.
It is multi-user safe because multiple clients can issue the <code>UPDATE</code>
statement and get their own sequence value with the <code>SELECT</code> statement
(or <code>mysql_insert_id()</code>), without affecting or being affected by other
clients that generate their own sequence values.

Note that <code>mysql_insert_id()</code> is only updated after <code>INSERT</code>
and <code>UPDATE</code> statements, so you can't use the C API function to
retrieve the value for <code>LAST_INSERT_ID(expr)</code> <em>after</em> executing other
SQL statements like <code>SELECT</code> or <code>SET</code>.

<br><br><br><A NAME="IDX1454"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SESSION_USER()</code></b></td>
 </tr>
</table>
<br>
<code><b>SESSION_USER()</b></code><DD></A>
<code>SESSION_USER()</code> is a synonym for <code>USER()</code>.

<br><br><br><A NAME="IDX1455"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SYSTEM_USER()</code></b></td>
 </tr>
</table>
<br>
<code><b>SYSTEM_USER()</b></code><DD></A>
<code>SYSTEM_USER()</code> is a synonym for <code>USER()</code>.

<br><br><br><A NAME="IDX1456"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>USER()</code></b></td>
 </tr>
</table>
<br>
<code><b>USER()</b></code><DD></A>
Returns the current MySQL username and hostname.


<PRE>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
</PRE>

The value indicates the username you specified when connecting to
the server, and the client host from which you connected. The value may be
different than that of <code>CURRENT_USER()</code>.

Prior to MySQL 3.22.11, the function value does not include the client
hostname.  You can extract just the username part, regardless of whether the
value includes a hostname part, like this:


<PRE>
mysql&#62; SELECT SUBSTRING_INDEX(USER(),_utf8'@',1);
        -&#62; 'davida'
</PRE>

Before MySQL 4.1, it is not necessary to convert the character set of the
literal string, so leave out the <code>_utf8</code>:


<PRE>
mysql&#62; SELECT SUBSTRING_INDEX(USER(),'@',1);
        -&#62; 'davida'
</PRE>

<br><br><br><A NAME="IDX1457"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>VERSION()</code></b></td>
 </tr>
</table>
<br>
<code><b>VERSION()</b></code><DD></A>
Returns a string that indicates the MySQL server version.


<PRE>
mysql&#62; SELECT VERSION();
        -&#62; '3.23.13-log'
</PRE>

Note that if your version string ends with <code>-log</code> this means that
logging is enabled.

</DL>



<H3><A NAME="Miscellaneous_functions" HREF="index.html#Miscellaneous_functions">13.8.4  Miscellaneous Functions</A></H3>

<P>
<A NAME="IDX1458"></A>
<A NAME="IDX1459"></A>

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1460"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>FORMAT(X,D)</code></b></td>
 </tr>
</table>
<br>
<code><b>FORMAT(X,D)</b></code><DD></A>
 
Formats the number <code>X</code> to a format like <code>'#,###,###.##'</code>, rounded
to <code>D</code> decimals, and returns the result as a string.
If <code>D</code> is <code>0</code>, the result will have no
decimal point or fractional part.


<PRE>
mysql&#62; SELECT FORMAT(12332.123456, 4);
        -&#62; '12,332.1235'
mysql&#62; SELECT FORMAT(12332.1,4);
        -&#62; '12,332.1000'
mysql&#62; SELECT FORMAT(12332.2,0);
        -&#62; '12,332'
</PRE>

<A NAME="IDX1461"></A>
<br><br><br><A NAME="IDX1462"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>GET_LOCK(str,timeout)</code></b></td>
 </tr>
</table>
<br>
<code><b>GET_LOCK(str,timeout)</b></code><DD></A>
Tries to obtain a lock with a name given by the string <code>str</code>, with a
timeout of <code>timeout</code> seconds.  Returns <code>1</code> if the lock was obtained
successfully, <code>0</code> if the attempt timed out (for example, because another
client has already locked the name), or <code>NULL</code> if an error
occurred (such as running out of memory or the thread was killed with
<code>mysqladmin kill</code>).  If you have a lock obtained with <code>GET_LOCK()</code>,
it is released when you execute
<code>RELEASE_LOCK()</code>, execute a new <code>GET_LOCK()</code>, or your connection
terminates (either normally or abnormally).

This function can be used to implement application locks or to
simulate record locks.  Names are locked on a server-wide basis.
If a name has been locked by one client, <code>GET_LOCK()</code> blocks
any request by another client for a lock with the same name. This
allows clients that agree on a given lock name to use the name to
perform cooperative advisory locking.


<PRE>
mysql&#62; SELECT GET_LOCK('lock1',10);
        -&#62; 1
mysql&#62; SELECT IS_FREE_LOCK('lock2');
        -&#62; 1
mysql&#62; SELECT GET_LOCK('lock2',10);
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK('lock2');
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK('lock1');
        -&#62; NULL
</PRE>

Note that the second <code>RELEASE_LOCK()</code> call returns <code>NULL</code> because
the lock <code>'lock1'</code> was automatically released by the second
<code>GET_LOCK()</code> call.

<br><br><br><A NAME="IDX1463"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>INET_ATON(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>INET_ATON(expr)</b></code><DD></A>
Given the dotted-quad representation of a network address as a string,
returns an integer that represents the numeric value of the address.
Addresses may be 4 or 8 byte addresses.


<PRE>
mysql&#62; SELECT INET_ATON('209.207.224.40');
        -&#62; 3520061480
</PRE>

The generated number is always in network byte order; in the example just
shown, the
number is calculated as <code>209*256^3 + 207*256^2 + 224*256 + 40</code>.

As of MySQL 4.1.2, <code>INET_ATON()</code> also understands short-form IP
addresses:


<PRE>
mysql&#62; SELECT INET_ATON('127.0.0.1'), INET_ATON('127.1');
        -&#62; 2130706433, 2130706433
</PRE>

<code>INET_ATON()</code> was added in MySQL 3.23.15.

<br><br><br><A NAME="IDX1464"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>INET_NTOA(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>INET_NTOA(expr)</b></code><DD></A>
Given a numeric network address (4 or 8 byte), returns the dotted-quad
representation of the address as a string.


<PRE>
mysql&#62; SELECT INET_NTOA(3520061480);
        -&#62; '209.207.224.40'
</PRE>

<code>INET_NTOA()</code> was added in MySQL 3.23.15.

<br><br><br><A NAME="IDX1465"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>IS_FREE_LOCK(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>IS_FREE_LOCK(str)</b></code><DD></A>
Checks if the lock named <code>str</code> is free to use (that is, not locked).
Returns <code>1</code> if the lock is free (no one is using the lock),
<code>0</code> if the lock is in use, and
<code>NULL</code> on errors (such as incorrect arguments).

<code>IS_FREE_LOCK()</code> was added in MySQL 4.0.2.

<br><br><br><A NAME="IDX1466"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>IS_USED_LOCK(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>IS_USED_LOCK(str)</b></code><DD></A>
Checks if the lock named <code>str</code> is in use (that is, locked).
If so, it returns the connection identifier of the client that holds
the lock.
Otherwise, it returns <code>NULL</code>.

<code>IS_USED_LOCK()</code> was added in MySQL 4.1.0.

<br><br><br><A NAME="IDX1467"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MASTER_POS_WAIT(log_name, log_pos [, timeout])</code></b></td>
 </tr>
</table>
<br>
<code><b>MASTER_POS_WAIT(log_name, log_pos [, timeout])</b></code><DD></A>
This function is useful for control of master/slave synchronization.
It blocks until the slave has read and applied all updates up to the specified
position in the master log.
The return value is the number of log events it had to wait for to get to
the specified position.  The function returns <code>NULL</code> if the slave's
master information is not initialized, the arguments are incorrect, or an
error occurs. It returns <code>-1</code> if the timeout has been exceeded.

If the slave thread is not running, this function will block and wait until
the slave is started and goes to or past the specified position. If the
slave is already past the specified position, the function returns
immediately.  @c end_description_for_help_topic

If <code>timeout</code> (new in 4.0.10) is specified, <code>MASTER_POS_WAIT()</code>
stops waiting when <code>timeout</code> seconds have elapsed. <code>timeout</code> must
be greater than 0; a zero or negative <code>timeout</code> means no timeout.

<br><br><br><A NAME="IDX1468"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>RELEASE_LOCK(str)</code></b></td>
 </tr>
</table>
<br>
<code><b>RELEASE_LOCK(str)</b></code><DD></A>
Releases the lock named by the string <code>str</code> that was obtained with
<code>GET_LOCK()</code>. Returns <code>1</code> if the lock was released, <code>0</code> if the
lock wasn't locked by this thread (in which case the lock is not released),
and <code>NULL</code> if the named lock didn't exist.  The lock will not exist if
it was never obtained by a call to <code>GET_LOCK()</code> or if it already has
been released.

The <code>DO</code> statement is convenient to use with <code>RELEASE_LOCK()</code>.
See section <A HREF="manual_SQL_Syntax.html#DO">14.1.2  <code>DO</code> Syntax</A>.

<br><br><br><A NAME="IDX1469"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>UUID()</code></b></td>
 </tr>
</table>
<br>
<code><b>UUID()</b></code><DD></A>
Returns a Universal Unique Identifier (UUID) generated
according to ``DCE 1.1: Remote Procedure Call'' (Appendix A)
CAE (Common Applications Environment) Specifications
published by the Open Group in October 1997 (Document Number C706).

A UUID is designed as a number that is unique globally in space and
time. Two calls to <code>UUID()</code> are expected to generate two different
values, even if these calls were performed on two separate computers that are
not connected to each other.

A UUID is a 128-bit number represented by a string
of 5 hexadecimal numbers in <code>aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee</code>
format:


<UL>

<LI>

The first three numbers are generated from a timestamp.

<LI>

The fourth number preserves temporal uniqueness in case the timestamp value loses
monotonicity (for example, due to daylight savings time).

<LI>

The fifth number is an IEEE 802 node number that provides spatial uniqueness.  A
random number is substituted if the latter is not available (for example,
because the host computer has no Ethernet card, or we do not know how to
find the hardware address of an interface on your operating system).  In
this case, spatial uniqueness cannot be guaranteed. Nevertheless, a
collision should have <em>very</em> low probability.

Currently, the MAC address of an interface is taken into account only on
FreeBSD and Linux. On other operating systems, MySQL uses a randomly generated
48-bit number.

</UL>


<PRE>
mysql&#62; SELECT UUID();
        -&#62; '6ccd780c-baba-1026-9564-0040f4311e29'
</PRE>

Note that <code>UUID()</code> does not work with replication yet.

<code>UUID()</code> was added in MySQL 4.1.2.

</DL>



<H2><A NAME="Group_by_functions_and_modifiers" HREF="index.html#Group_by_functions_and_modifiers">13.9  Functions and Modifiers for Use with <code>GROUP BY</code> Clauses</A></H2>



<H3><A NAME="GROUP-BY-Functions" HREF="index.html#GROUP-BY-Functions">13.9.1  <code>GROUP BY</code> Functions</A></H3>

<P>
<A NAME="IDX1470"></A>
<A NAME="IDX1471"></A>

</P>
<P>
If you use a group function in a statement containing no <code>GROUP BY</code>
clause, it is equivalent to grouping on all rows.

</P>
<DL COMPACT>

<br><br><br><A NAME="IDX1472"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>AVG(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>AVG(expr)</b></code><DD></A>
 
Returns the average value of <code>expr</code>.


<PRE>
mysql&#62; SELECT student_name, AVG(test_score)
    -&#62;        FROM student
    -&#62;        GROUP BY student_name;
</PRE>

<br><br><br><A NAME="IDX1473"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIT_AND(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIT_AND(expr)</b></code><DD></A>
Returns the bitwise <code>AND</code> of all bits in <code>expr</code>. The calculation is
performed with 64-bit (<code>BIGINT</code>) precision.

As of MySQL 4.0.17, this function returns
<code>18446744073709551615</code> if there were no matching rows.
(This is an unsigned <code>BIGINT</code> value with all bits set to 1.)
Before 4.0.17, the function returns <code>-1</code> if there were no matching rows.

<br><br><br><A NAME="IDX1474"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIT_OR(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIT_OR(expr)</b></code><DD></A>
Returns the bitwise <code>OR</code> of all bits in <code>expr</code>. The calculation is
performed with 64-bit (<code>BIGINT</code>) precision.

This function returns <code>0</code> if there were no matching rows.

<br><br><br><A NAME="IDX1475"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>BIT_XOR(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>BIT_XOR(expr)</b></code><DD></A>
Returns the bitwise <code>XOR</code> of all bits in <code>expr</code>. The calculation is
performed with 64-bit (<code>BIGINT</code>) precision.

This function returns <code>0</code> if there were no matching rows.

This function is available as of MySQL 4.1.1.

<br><br><br><A NAME="IDX1476"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COUNT(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>COUNT(expr)</b></code><DD></A>
Returns a count of the number of non-<code>NULL</code> values in the rows
retrieved by a <code>SELECT</code> statement.


<PRE>
mysql&#62; SELECT student.student_name,COUNT(*)
    -&#62;        FROM student,course
    -&#62;        WHERE student.student_id=course.student_id
    -&#62;        GROUP BY student_name;

</PRE>

<code>COUNT(*)</code> is somewhat different in that it returns a count of
the number of rows retrieved, whether or not they contain <code>NULL</code>
values.

<code>COUNT(*)</code> is optimized to
return very quickly if the <code>SELECT</code> retrieves from one table, no
other columns are retrieved, and there is no <code>WHERE</code> clause.
For example:


<PRE>
mysql&#62; SELECT COUNT(*) FROM student;
</PRE>

This optimization applies only to <code>MyISAM</code> and <code>ISAM</code> tables
only, because an exact record count is stored for these table types and
can be accessed very quickly. For transactional storage engines
(<code>InnoDB</code>, <code>BDB</code>), storing an exact row count is more problematic
because multiple transactions may be occurring, each of which may affect the
count.

<A NAME="IDX1477"></A>
<br><br><br><A NAME="IDX1478"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>COUNT(DISTINCT expr,[expr...])</code></b></td>
 </tr>
</table>
<br>
<code><b>COUNT(DISTINCT expr,[expr...])</b></code><DD></A>
Returns a count of the number of different non-<code>NULL</code> values.


<PRE>
mysql&#62; SELECT COUNT(DISTINCT results) FROM student;
</PRE>

In MySQL, you can get the number of distinct expression
combinations that don't contain <code>NULL</code> by giving a list of expressions.
In SQL-99, you would have to do a concatenation of all expressions
inside <code>COUNT(DISTINCT ...)</code>.

<code>COUNT(DISTINCT ...)</code> was added in MySQL 3.23.2.

<br><br><br><A NAME="IDX1479"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>GROUP_CONCAT(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>GROUP_CONCAT(expr)</b></code><DD></A>
This function returns a string result with the concatenated values from a
group.  The full syntax is as follows:


<PRE>
GROUP_CONCAT([DISTINCT] expr [,expr ...]
             [ORDER BY {unsigned_integer | col_name | formula}
                 [ASC | DESC] [,col ...]]
             [SEPARATOR str_val])
</PRE>

<code>GROUP_CONCAT()</code> was added in MySQL 4.1.


<PRE>
mysql&#62; SELECT student_name,
    -&#62;     GROUP_CONCAT(test_score)
    -&#62;     FROM student 
    -&#62;     GROUP BY student_name;
</PRE>

Or:


<PRE>
mysql&#62; SELECT student_name,
    -&#62;     GROUP_CONCAT(DISTINCT test_score
    -&#62;               ORDER BY test_score DESC SEPARATOR ' ')
    -&#62;     FROM student
    -&#62;     GROUP BY student_name;
</PRE>

In MySQL, you can get the concatenated values of expression combinations.
You can eliminate duplicate values by using <code>DISTINCT</code>.
If you want to sort values in the result, you should use <code>ORDER BY</code>
clause.
To sort in reverse order, add the <code>DESC</code> (descending) keyword to the
name of the column you are sorting by in the <code>ORDER BY</code> clause. The
default is ascending order; this may be specified explicitly using the
<code>ASC</code> keyword.
<code>SEPARATOR</code> is followed by the string value that should be inserted between
values of result. The default is a comma (<samp>`,'</samp>). You can remove
the separator altogether by specifying <code>SEPARATOR ''</code>.

You can set a maximum allowed length with the
<code>group_concat_max_len</code> system variable.
The syntax to do this at runtime is as follows, where <code>val</code> is an
unsigned integer:


<PRE>
SET [SESSION | GLOBAL] group_concat_max_len = val;
</PRE>

If a maximum length has been set, the result is truncated to this
maximum length. 

The <code>GROUP_CONCAT()</code> function is an enhanced implementation of
the basic <code>LIST()</code> function supported by Sybase SQL Anywhere.
<code>GROUP_CONCAT()</code> is backward compatible with the extremely limited
functionality of <code>LIST()</code> if only one column and no other options
are specified. <code>LIST()</code> does have a default sorting order.

<A NAME="IDX1480"></A>
<br><br><br><A NAME="IDX1481"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>MIN(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>MIN(expr)</b></code><DD></A>
<DT><code><b>MAX(expr)</b></code><DD>
Returns the minimum or maximum value of <code>expr</code>.  <code>MIN()</code> and
<code>MAX()</code> may take a string argument; in such cases they return the
minimum or maximum string value. See section 7.4.5  How MySQL Uses Indexes.


<PRE>
mysql&#62; SELECT student_name, MIN(test_score), MAX(test_score)
    -&#62;        FROM student
    -&#62;        GROUP BY student_name;
</PRE>

For <code>MIN()</code>, <code>MAX()</code>, and other aggregate functions, MySQL
currently compares <code>ENUM</code> and <code>SET</code> columns by their string
value rather than by the string's relative position in the set.
This will be rectified.

<A NAME="IDX1482"></A>
<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>
<br><br><br><A NAME="IDX1485"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>STD(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>STD(expr)</b></code><DD></A>
<DT><code><b>STDDEV(expr)</b></code><DD>
Returns the standard deviation of <code>expr</code> (the square root of
<code>VARIANCE()</code>). This is an extension to SQL-99. The <code>STDDEV()</code>
form of this function is provided for Oracle compatibility.

<br><br><br><A NAME="IDX1486"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>SUM(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>SUM(expr)</b></code><DD></A>
Returns the sum of <code>expr</code>.  Note that if the return set has no rows,
it returns <code>NULL</code>!

<br><br><br><A NAME="IDX1487"><font style="font-size: 4px"><br></font>
<DT>
<table border="0" cellspacing="0" cellpadding="3" width="100%" bgcolor="#99CCFF" bordercolor="#999999" style="border-color:#999999; border-style:solid; border-width:1;">
 <tr>
   <td><i>MySQL Inline-Help Reference - SQL Functions</i></td> </tr>
 <tr>
   <td><b><code>VARIANCE(expr)</code></b></td>
 </tr>
</table>
<br>
<code><b>VARIANCE(expr)</b></code><DD></A>
Returns the standard variance of <code>expr</code> (considering rows as the
whole population, not as a sample; so it has the number of rows as
denominator). This is an extension to 
SQL-99, available only in MySQL 4.1 or later.

</DL>



<H3><A NAME="GROUP-BY-Modifiers" HREF="index.html#GROUP-BY-Modifiers">13.9.2  <code>GROUP BY</code> Modifiers</A></H3>

<P>
<A NAME="IDX1488"></A>

</P>

<P>
As of MySQL 4.1.1, the <code>GROUP BY</code> clause allows a <code>WITH
ROLLUP</code> modifier that causes extra rows to be added to the summary
output. These rows represent higher-level (or super-aggregate) summary
operations. <code>ROLLUP</code> thus allows you to answer questions at multiple
levels of analysis with a single query. It can be used, for example,
to provide support for OLAP (Online Analytical Processing) operations.

</P>
<P>
As an illustration, suppose that a table named <code>sales</code> has <code>year</code>,
<code>country</code>,
<code>product</code>, and <code>profit</code> columns for recording sales profitability:

</P>

<PRE>
CREATE TABLE sales
(
    year    INT NOT NULL,
    country VARCHAR(20) NOT NULL,
    product VARCHAR(32) NOT NULL,
    profit  INT
);
</PRE>

<P>
The table's contents can be summarized per year with a simple <code>GROUP BY</code>
like this:

</P>

<PRE>
mysql&#62; SELECT year, SUM(profit) FROM sales GROUP BY year;
+------+-------------+
| year | SUM(profit) |
+------+-------------+
| 2000 |        4525 |
| 2001 |        3010 |
+------+-------------+
</PRE>

<P>
This output shows the total profit for each year, but if you also want
to determine the total profit summed over all years, you must add up
the individual values yourself or run an additional query.

</P>
<P>
Or you can use <code>ROLLUP</code>, which provides both levels of analysis with a
single query.
Adding a <code>WITH ROLLUP</code> modifier to the <code>GROUP BY</code> clause causes the query
to produce another row that shows the grand total over all year values:

</P>

<PRE>
mysql&#62; SELECT year, SUM(profit) FROM sales GROUP BY year WITH ROLLUP;
+------+-------------+
| year | SUM(profit) |
+------+-------------+
| 2000 |        4525 |
| 2001 |        3010 |
| NULL |        7535 |
+------+-------------+
</PRE>

<P>
The grand total super-aggregate line is identified by the value <code>NULL</code> in
the <code>year</code> column.

</P>
<P>
<code>ROLLUP</code> has a more complex effect when there are multiple <code>GROUP BY</code>
columns. In this case, each time there is a ``break'' (change in value)
in any but the last grouping column, the query produces an extra
super-aggregate summary row.

</P>
<P>
For example, without <code>ROLLUP</code>, a summary on the <code>sales</code> table based
on <code>year</code>,
<code>country</code>, and <code>product</code> might look like this:

</P>

<PRE>
mysql&#62; SELECT year, country, product, SUM(profit)
    -&#62; FROM sales
    -&#62; GROUP BY year, country, product;
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
| 2000 | USA     | Calculator |          75 |
| 2000 | USA     | Computer   |        1500 |
| 2001 | Finland | Phone      |          10 |
| 2001 | USA     | Calculator |          50 |
| 2001 | USA     | Computer   |        2700 |
| 2001 | USA     | TV         |         250 |
+------+---------+------------+-------------+
</PRE>

<P>
The output indicates summary values only at the year/country/product level of
analysis.  When <code>ROLLUP</code> is added, the query produces several extra rows:

</P>

<PRE>
mysql&#62; SELECT year, country, product, SUM(profit)
    -&#62; FROM sales
    -&#62; GROUP BY year, country, product WITH ROLLUP;
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | Finland | NULL       |        1600 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
| 2000 | India   | NULL       |        1350 |
| 2000 | USA     | Calculator |          75 |
| 2000 | USA     | Computer   |        1500 |
| 2000 | USA     | NULL       |        1575 |
| 2000 | NULL    | NULL       |        4525 |
| 2001 | Finland | Phone      |          10 |
| 2001 | Finland | NULL       |          10 |
| 2001 | USA     | Calculator |          50 |
| 2001 | USA     | Computer   |        2700 |
| 2001 | USA     | TV         |         250 |
| 2001 | USA     | NULL       |        3000 |
| 2001 | NULL    | NULL       |        3010 |
| NULL | NULL    | NULL       |        7535 |
+------+---------+------------+-------------+
</PRE>

<P>
For this query, adding <code>ROLLUP</code> causes the output to include summary
information at four levels of analysis, not just one.  Here's how to
interpret the <code>ROLLUP</code> output:

</P>

<UL>

<LI>

Following each set of product rows for a given year and country, an
extra summary row is produced showing the total for all products. These rows
have the <code>product</code> column set to <code>NULL</code>.

<LI>

Following each set of rows for a given year, an extra summary row is
produced showing the total for all countries and products. These rows
have the <code>country</code> and <code>products</code> columns set to <code>NULL</code>.

<LI>

Finally, following all other rows, an extra summary row is produced
showing the grand total for all years, countries, and products. This
row has the <code>year</code>, <code>country</code>, and <code>products</code> columns set to
<code>NULL</code>.

</UL>

<P>
<strong>Other Considerations When using <code>ROLLUP</code></strong>

</P>
<P>
The following items list some behaviors specific to the MySQL implementation
of <code>ROLLUP</code>:

</P>
<P>
When you use <code>ROLLUP</code>, you cannot also use an <code>ORDER BY</code> clause to
sort the results. In other words, <code>ROLLUP</code> and <code>ORDER BY</code> are mutually
exclusive. However, you still have some control over sort order.
<code>GROUP BY</code>
in MySQL sorts results, and you can use explicit <code>ASC</code> and <code>DESC</code> keywords
with columns named in the <code>GROUP BY</code> list to specify sort order for
individual columns.  (The higher-level summary rows added by <code>ROLLUP</code>
still appear after the rows from which they are calculated, regardless
of the sort order.)

</P>
<P>
<code>LIMIT</code> can be used to restrict the number of rows returned to the
client. <code>LIMIT</code> is applied after <code>ROLLUP</code>, so the limit applies
against the extra rows added by <code>ROLLUP</code>. For example:

</P>

<PRE>
mysql&#62; SELECT year, country, product, SUM(profit)
    -&#62; FROM sales
    -&#62; GROUP BY year, country, product WITH ROLLUP
    -&#62; LIMIT 5;
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | Finland | NULL       |        1600 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
+------+---------+------------+-------------+
</PRE>

<P>
Using <code>LIMIT</code> with <code>ROLLUP</code> may produce results
that are more difficult to interpret, because you have less context
for understanding the super-aggregate rows.

</P>
<P>
The <code>NULL</code> indicators in each super-aggregate row are produced when the
row is sent to the client.  The server looks at the columns named in
the <code>GROUP BY</code> clause following the leftmost one that has changed value.
For any column in the result set with a name that is a lexical match to
any of those names, its value is set to <code>NULL</code>.  (If you specify grouping
columns by column number, the server identifies which columns to set to
<code>NULL</code> by number.)

</P>
<P>
Because the <code>NULL</code> values in the super-aggregate rows are placed into the
result set at such a late stage in query processing, you cannot test them
as <code>NULL</code> values within the query itself.  For example, you cannot add
<code>HAVING product IS NULL</code> to the query to eliminate from the output all
but the super-aggregate rows.

</P>
<P>
On the other hand, the <code>NULL</code> values do appear as <code>NULL</code>
on the client side and can be tested as such using any MySQL client
programming interface.

</P>


<H3><A NAME="GROUP-BY-hidden-fields" HREF="index.html#GROUP-BY-hidden-fields">13.9.3  <code>GROUP BY</code> with Hidden Fields</A></H3>

<P>
<A NAME="IDX1489"></A>
MySQL extends the use of <code>GROUP BY</code> so that you can use columns or
calculations in the <code>SELECT</code> list that don't appear in
the <code>GROUP BY</code> clause. This stands for <em>any possible value for this
group</em>.  You can use this to get better performance by avoiding sorting and
grouping on unnecessary items.  For example, you don't need to group on
<code>customer.name</code> in the following query:

</P>

<PRE>
mysql&#62; SELECT order.custid, customer.name, MAX(payments)
    -&#62;        FROM order,customer
    -&#62;        WHERE order.custid = customer.custid
    -&#62;        GROUP BY order.custid;
</PRE>

<P>
In standard SQL, you would have to add <code>customer.name</code> to the
<code>GROUP BY</code> clause.  In MySQL, the name is redundant if you don't run in
ANSI mode.

</P>
<P>
Do <em>not</em> use this feature if the columns you omit from the
<code>GROUP BY</code> part are not unique in the group!  You will get
unpredictable results.

</P>
<P>
In some cases, you can use <code>MIN()</code> and <code>MAX()</code> to obtain a specific
column value even if it isn't unique. The following gives the value of
<code>column</code> from the row containing the smallest value in the <code>sort</code>
column:

</P>

<PRE>
SUBSTR(MIN(CONCAT(RPAD(sort,6,' '),column)),7)
</PRE>

<P>
See section 3.6.4  The Rows Holding the Group-wise Maximum of a Certain Field.

</P>
<P>
<A NAME="IDX1490"></A>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
<A NAME="IDX1495"></A>
Note that if you are using MySQL 3.22 (or earlier) or if
you are trying to follow SQL-99, you can't use expressions in <code>GROUP
BY</code> or <code>ORDER BY</code> clauses.  You can work around this limitation by
using an alias for the expression:

</P>

<PRE>
mysql&#62; SELECT id,FLOOR(value/100) AS val FROM tbl_name
    -&#62;     GROUP BY id, val ORDER BY val;
</PRE>

<P>
In MySQL 3.23 and up, aliases are unnecessary. You can use expressions 
in <code>GROUP BY</code> and <code>ORDER BY</code> clauses.  For example:

</P>

<PRE>
mysql&#62; SELECT id, FLOOR(value/100) FROM tbl_name ORDER BY RAND();
</PRE>

 </BODY>
 </HTML>
